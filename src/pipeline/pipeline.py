"""Compatibility wrapper for renamed execution module."""

from __future__ import annotations

import asyncio
import json
import os
import time
from datetime import datetime
from typing import Any, Dict

from registry import SystemRegistries

from .context import ConversationEntry, PluginContext, SimpleContext
from .errors import create_static_error_response
from .exceptions import CircuitBreakerTripped, PluginExecutionError
from .logging import reset_request_id, set_request_id
from .manager import PipelineManager
from .observability.metrics import _metrics_server
from .observability.tracing import start_span
from .stages import PipelineStage
from .state import FailureInfo, MetricsCollector, PipelineState, ToolCall
from .tools.base import RetryOptions
from .tools.execution import execute_tool
from .user_plugins import AutoGeneratedPlugin


def generate_pipeline_id() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S%f")


def create_default_response(message: str, pipeline_id: str) -> Dict[str, Any]:
    return {
        "message": message,
        "pipeline_id": pipeline_id,
        "timestamp": datetime.now().isoformat(),
        "type": "default_response",
    }


async def execute_stage(
    stage: PipelineStage, state: PipelineState, registries: SystemRegistries
) -> None:
    state.current_stage = stage
    stage_plugins = registries.plugins.get_plugins_for_stage(stage)
    async with start_span(f"stage.{stage.name.lower()}"):
        for plugin in stage_plugins:
            context_cls = (
                SimpleContext
                if isinstance(plugin, AutoGeneratedPlugin)
                else PluginContext
            )
            context = context_cls(state, registries)
            token = set_request_id(state.pipeline_id)
            try:
                await plugin.execute(context)
                if state.pending_tool_calls:
                    tool_results = await execute_pending_tools(state, registries)
                    for call in state.pending_tool_calls:
                        result = tool_results.get(call.result_key)
                        context.add_conversation_entry(
                            content=f"Tool result: {result}",
                            role="system",
                            metadata={"tool_name": call.name, "stage": str(stage)},
                        )
                    state.pending_tool_calls.clear()
            except CircuitBreakerTripped as exc:
                state.failure_info = FailureInfo(
                    stage=str(stage),
                    plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                    error_type="circuit_breaker",
                    error_message=str(exc),
                    original_exception=exc,
                )
                return
            except PluginExecutionError as exc:
                state.failure_info = FailureInfo(
                    stage=str(stage),
                    plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                    error_type=exc.original_exception.__class__.__name__,
                    error_message=str(exc.original_exception),
                    original_exception=exc.original_exception,
                )
                return
            except Exception as exc:  # noqa: BLE001
                state.failure_info = FailureInfo(
                    stage=str(stage),
                    plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                    error_type=exc.__class__.__name__,
                    error_message=str(exc),
                    original_exception=exc,
                )
                return
            finally:
                reset_request_id(token)


async def execute_pipeline(
    user_message: str,
    registries: SystemRegistries,
    *,
    state_file: str | None = None,
    pipeline_manager: PipelineManager | None = None,
    return_metrics: bool = False,
) -> Dict[str, Any] | tuple[Dict[str, Any], MetricsCollector]:
    if state_file and os.path.exists(state_file):
        with open(state_file, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        state = PipelineState.from_dict(data)
    else:
        state = PipelineState(
            conversation=[
                ConversationEntry(
                    content=user_message, role="user", timestamp=datetime.now()
                )
            ],
            pipeline_id=generate_pipeline_id(),
            metrics=MetricsCollector(),
        )
    start = time.time()
    if pipeline_manager is not None:
        await pipeline_manager.register(state.pipeline_id)
    try:
        async with start_span("pipeline.execute"):
            for stage in [
                PipelineStage.PARSE,
                PipelineStage.THINK,
                PipelineStage.DO,
                PipelineStage.REVIEW,
                PipelineStage.DELIVER,
            ]:
                if (
                    state.last_completed_stage is not None
                    and stage.value <= state.last_completed_stage.value
                ):
                    continue
                await execute_stage(stage, state, registries)
                if state.failure_info:
                    break
                state.last_completed_stage = stage
                if state_file:
                    with open(state_file, "w", encoding="utf-8") as fh:
                        json.dump(state.to_dict(), fh)

        if state.failure_info:
            try:
                await execute_stage(PipelineStage.ERROR, state, registries)
            except Exception:
                result = create_static_error_response(state.pipeline_id)
                return (result, state.metrics) if return_metrics else result
            if state.response is None:
                result = create_static_error_response(state.pipeline_id)
                return (result, state.metrics) if return_metrics else result
            result = state.response
        elif state.response is None:
            result = create_default_response("No response generated", state.pipeline_id)
        else:
            result = state.response
        return (result, state.metrics) if return_metrics else result
    finally:
        if pipeline_manager is not None:
            await pipeline_manager.deregister(state.pipeline_id)
        state.metrics.record_pipeline_duration(time.time() - start)
        if state_file and os.path.exists(state_file):
            os.remove(state_file)
        if _metrics_server is not None:
            _metrics_server.update(state.metrics)


async def execute_pending_tools(
    state: PipelineState, registries: SystemRegistries, timeout: int | None = None
) -> Dict[str, Any]:
    """Execute queued tools and return their results keyed by ``result_key``."""

    results: Dict[str, Any] = {}
    calls = list(state.pending_tool_calls)
    state.pending_tool_calls.clear()

    async def run_call(call: ToolCall) -> None:
        tool = registries.tools.get(call.name)
        if not tool:
            err = f"Error: tool {call.name} not found"
            state.stage_results[call.result_key] = err
            results[call.result_key] = err
            return

        options = RetryOptions(
            max_retries=getattr(tool, "max_retries", 1),
            delay=getattr(tool, "retry_delay", 1.0),
        )

        try:
            coro = execute_tool(tool, call, state, options)
            if timeout is not None:
                result = await asyncio.wait_for(coro, timeout)
            else:
                result = await coro
            state.stage_results[call.result_key] = result
            results[call.result_key] = result
            state.metrics.record_tool_execution(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                call.result_key,
                call.source,
            )
        except Exception as exc:
            err = f"Error: {exc}"
            state.stage_results[call.result_key] = err
            results[call.result_key] = err
            state.metrics.record_tool_error(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                str(exc),
            )

    await asyncio.gather(*(run_call(call) for call in calls))
    return results


__all__ = [
    "generate_pipeline_id",
    "create_default_response",
    "execute_stage",
    "execute_pipeline",
    "execute_pending_tools",
]
