from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict

from .context import PipelineState, ConversationEntry, PluginContext, SimpleContext
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage
from .plugins import AutoGeneratedPlugin, BasePlugin


def generate_pipeline_id() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S%f")


def create_default_response(message: str, pipeline_id: str) -> Dict[str, Any]:
    return {
        "message": message,
        "pipeline_id": pipeline_id,
        "timestamp": datetime.now().isoformat(),
        "type": "default_response",
    }


@dataclass
class SystemRegistries:
    resources: ResourceRegistry
    tools: ToolRegistry
    plugins: PluginRegistry


async def execute_stage(stage: PipelineStage, state: PipelineState, registries: SystemRegistries):
    state.current_stage = stage
    stage_plugins = registries.plugins.get_for_stage(stage)
    for plugin in stage_plugins:
        if isinstance(plugin, AutoGeneratedPlugin):
            context = SimpleContext(state, registries)
        else:
            context = PluginContext(state, registries)
        await plugin.execute(context)
        if state.pending_tool_calls:
            await execute_pending_tools(state, registries)
            state.pending_tool_calls.clear()


async def execute_pipeline(user_message: str, registries: SystemRegistries) -> Dict[str, Any]:
    state = PipelineState(
        conversation=[ConversationEntry(content=user_message, role="user", timestamp=datetime.now())],
        pipeline_id=generate_pipeline_id(),
    )
    for stage in [PipelineStage.PARSE, PipelineStage.THINK, PipelineStage.DO, PipelineStage.REVIEW, PipelineStage.DELIVER]:
        await execute_stage(stage, state, registries)
    if state.response is None:
        return create_default_response("No response generated", state.pipeline_id)
    return state.response


async def execute_pending_tools(state: PipelineState, registries: SystemRegistries):
    for call in state.pending_tool_calls:
        tool = registries.tools.get(call.name)
        if not tool:
            state.stage_results[call.result_key] = f"Error: tool {call.name} not found"
            continue
        if hasattr(tool, "execute_function_with_retry"):
            result = await tool.execute_function_with_retry(call.params)
        elif hasattr(tool, "execute_function"):
            result = await tool.execute_function(call.params)
        else:
            func = getattr(tool, "run", None)
            if asyncio.iscoroutinefunction(func):
                result = await func(call.params)
            else:
                result = func(call.params)
        state.stage_results[call.result_key] = result
