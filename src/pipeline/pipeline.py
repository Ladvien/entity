"""Compatibility wrapper for renamed execution module."""

from __future__ import annotations

import asyncio
import time
from datetime import datetime
from typing import Any, Dict, cast

from registry import SystemRegistries

from .context import ConversationEntry, PluginContext
from .errors import create_static_error_response
from .exceptions import CircuitBreakerTripped, PluginExecutionError
from .manager import PipelineManager
from .plugins import AutoGeneratedPlugin
from .stages import PipelineStage
from .state import FailureInfo, MetricsCollector, PipelineState, ToolCall


def generate_pipeline_id() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S%f")


def create_default_response(message: str, pipeline_id: str) -> Dict[str, Any]:
    return {
        "message": message,
        "pipeline_id": pipeline_id,
        "timestamp": datetime.now().isoformat(),
        "type": "default_response",
    }


async def execute_stage(
    stage: PipelineStage, state: PipelineState, registries: SystemRegistries
) -> None:
    state.current_stage = stage
    stage_plugins = registries.plugins.get_plugins_for_stage(stage)
    for plugin in stage_plugins:
        context = PluginContext(state, registries)
        try:
            await plugin.execute(context)
        except CircuitBreakerTripped as exc:
            state.failure_info = FailureInfo(
                stage=str(stage),
                plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                error_type="circuit_breaker",
                error_message=str(exc),
                original_exception=exc,
            )
            return
        except PluginExecutionError as exc:
            state.failure_info = FailureInfo(
                stage=str(stage),
                plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                error_type=exc.original_exception.__class__.__name__,
                error_message=str(exc.original_exception),
                original_exception=exc.original_exception,
            )
            return
        except Exception as exc:  # noqa: BLE001
            state.failure_info = FailureInfo(
                stage=str(stage),
                plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                error_type=exc.__class__.__name__,
                error_message=str(exc),
                original_exception=exc,
            )
            return
        if state.pending_tool_calls:
            tool_results = await execute_pending_tools(state, registries)
            for call in state.pending_tool_calls:
                result = tool_results.get(call.result_key)
                context.add_conversation_entry(
                    content=f"Tool result: {result}",
                    role="system",
                    metadata={"tool_name": call.name, "stage": str(stage)},
                )
            state.pending_tool_calls.clear()


async def execute_pipeline(
    user_message: str,
    registries: SystemRegistries,
    pipeline_manager: PipelineManager | None = None,
    return_metrics: bool = False,
) -> Dict[str, Any] | tuple[Dict[str, Any], MetricsCollector]:
    state = PipelineState(
        conversation=[
            ConversationEntry(
                content=user_message, role="user", timestamp=datetime.now()
            )
        ],
        pipeline_id=generate_pipeline_id(),
        metrics=MetricsCollector(),
    )
    start = time.time()
    if pipeline_manager is not None:
        await pipeline_manager.register(state.pipeline_id)
    try:
        for stage in [
            PipelineStage.PARSE,
            PipelineStage.THINK,
            PipelineStage.DO,
            PipelineStage.REVIEW,
            PipelineStage.DELIVER,
        ]:
            await execute_stage(stage, state, registries)
            if state.failure_info:
                break

        if state.failure_info:
            try:
                await execute_stage(PipelineStage.ERROR, state, registries)
            except Exception:
                result = create_static_error_response(state.pipeline_id)
                return (result, state.metrics) if return_metrics else result
            if state.response is None:
                result = create_static_error_response(state.pipeline_id)
                return (result, state.metrics) if return_metrics else result
            result = state.response
        elif state.response is None:
            result = create_default_response("No response generated", state.pipeline_id)
        else:
            result = state.response
        return (result, state.metrics) if return_metrics else result
    finally:
        if pipeline_manager is not None:
            await pipeline_manager.deregister(state.pipeline_id)
        state.metrics.record_pipeline_duration(time.time() - start)


async def execute_pending_tools(
    state: PipelineState, registries: SystemRegistries, timeout: int | None = None
) -> Dict[str, Any]:
    """Execute queued tools and return their results keyed by ``result_key``."""

    results: Dict[str, Any] = {}
    calls = list(state.pending_tool_calls)
    state.pending_tool_calls.clear()

    async def run_call(call: ToolCall) -> None:
        tool = registries.tools.get(call.name)
        if not tool:
            err = f"Error: tool {call.name} not found"
            state.stage_results[call.result_key] = err
            results[call.result_key] = err
            return

        try:
            coro = cast(Any, tool).execute(call.params)
            if timeout is not None:
                result = await asyncio.wait_for(coro, timeout)
            else:
                result = await coro
            state.stage_results[call.result_key] = result
            results[call.result_key] = result
            state.metrics.record_tool_execution(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                call.result_key,
                call.source,
            )
        except Exception as exc:
            err = f"Error: {exc}"
            state.stage_results[call.result_key] = err
            results[call.result_key] = err
            state.metrics.record_tool_error(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                str(exc),
            )

    await asyncio.gather(*(run_call(call) for call in calls))
    return results


__all__ = [
    "generate_pipeline_id",
    "create_default_response",
    "execute_stage",
    "execute_pipeline",
    "execute_pending_tools",
]
