from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List

from .context import (
    ConversationEntry,
    MetricsCollector,
    PipelineState,
    PluginContext,
    SimpleContext,
    ToolCall,
)
from .plugins import AutoGeneratedPlugin, BasePlugin
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage


def generate_pipeline_id() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S%f")


def create_default_response(message: str, pipeline_id: str) -> Dict[str, Any]:
    return {
        "message": message,
        "pipeline_id": pipeline_id,
        "timestamp": datetime.now().isoformat(),
        "type": "default_response",
    }


@dataclass
class SystemRegistries:
    resources: ResourceRegistry
    tools: ToolRegistry
    plugins: PluginRegistry


async def execute_stage(
    stage: PipelineStage, state: PipelineState, registries: SystemRegistries
) -> None:
    state.current_stage = stage
    stage_plugins = registries.plugins.get_for_stage(stage)
    for plugin in stage_plugins:
        context_cls = (
            SimpleContext if isinstance(plugin, AutoGeneratedPlugin) else PluginContext
        )
        context = context_cls(state, registries)
        await plugin.execute(context)
        if state.pending_tool_calls:
            tool_results = await execute_pending_tools(state, registries)
            for call, result in tool_results.items():
                context.add_conversation_entry(
                    content=f"Tool result: {result}",
                    role="system",
                    metadata={"tool_name": call.name, "stage": str(stage)},
                )
            state.pending_tool_calls.clear()


async def execute_pipeline(
    user_message: str, registries: SystemRegistries
) -> Dict[str, Any]:
    state = PipelineState(
        conversation=[
            ConversationEntry(
                content=user_message, role="user", timestamp=datetime.now()
            )
        ],
        pipeline_id=generate_pipeline_id(),
        metrics=MetricsCollector(),
    )
    for stage in [
        PipelineStage.PARSE,
        PipelineStage.THINK,
        PipelineStage.DO,
        PipelineStage.REVIEW,
        PipelineStage.DELIVER,
    ]:
        await execute_stage(stage, state, registries)
    if state.response is None:
        return create_default_response("No response generated", state.pipeline_id)
    return state.response


async def execute_pending_tools(
    state: PipelineState, registries: SystemRegistries
) -> Dict[ToolCall, Any]:
    results: Dict[ToolCall, Any] = {}
    for call in state.pending_tool_calls:
        tool = registries.tools.get(call.name)
        if not tool:
            error_msg = f"Error: tool {call.name} not found"
            state.stage_results[call.result_key] = error_msg
            results[call] = error_msg
            continue

        try:
            if hasattr(tool, "execute_function_with_retry"):
                result = await tool.execute_function_with_retry(call.params)
            elif hasattr(tool, "execute_function"):
                result = await tool.execute_function(call.params)
            else:
                func = getattr(tool, "run", None)
                if asyncio.iscoroutinefunction(func):
                    result = await func(call.params)
                else:
                    result = func(call.params)
            state.stage_results[call.result_key] = result
            results[call] = result
            state.metrics.record_tool_execution(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                call.result_key,
                call.source,
            )
        except Exception as exc:
            err = f"Error: {exc}"
            state.stage_results[call.result_key] = err
            results[call] = err
            state.metrics.record_tool_error(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                str(exc),
            )
    return results
