from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, List, cast

from .context import (
    ConversationEntry,
    FailureInfo,
    MetricsCollector,
    PipelineState,
    PluginContext,
    SimpleContext,
    ToolCall,
)
from .manager import PipelineManager
from .plugins import AutoGeneratedPlugin, BasePlugin
from .registries import SystemRegistries
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage


def generate_pipeline_id() -> str:
    return datetime.now().strftime("%Y%m%d%H%M%S%f")


def create_default_response(message: str, pipeline_id: str) -> Dict[str, Any]:
    return {
        "message": message,
        "pipeline_id": pipeline_id,
        "timestamp": datetime.now().isoformat(),
        "type": "default_response",
    }


STATIC_ERROR_RESPONSE = {
    "error": "System error occurred",
    "message": "An unexpected error prevented processing your request.",
    "error_id": None,
    "timestamp": None,
    "type": "static_fallback",
}


def create_static_error_response(pipeline_id: str) -> Dict[str, Any]:
    response = STATIC_ERROR_RESPONSE.copy()
    response["error_id"] = pipeline_id
    response["timestamp"] = datetime.now().isoformat()
    return response


async def execute_stage(
    stage: PipelineStage, state: PipelineState, registries: SystemRegistries
) -> None:
    state.current_stage = stage
    stage_plugins = registries.plugins.get_for_stage(stage)
    for plugin in stage_plugins:
        context_cls = (
            SimpleContext if isinstance(plugin, AutoGeneratedPlugin) else PluginContext
        )
        context = context_cls(state, registries)
        try:
            await plugin.execute(context)
        except Exception as exc:
            state.failure_info = FailureInfo(
                stage=str(stage),
                plugin_name=getattr(plugin, "name", plugin.__class__.__name__),
                error_type="plugin_error",
                error_message=str(exc),
                original_exception=exc,
            )
            return
        if state.pending_tool_calls:
            tool_results = await execute_pending_tools(state, registries)
            for call, result in tool_results.items():
                context.add_conversation_entry(
                    content=f"Tool result: {result}",
                    role="system",
                    metadata={"tool_name": call.name, "stage": str(stage)},
                )
            state.pending_tool_calls.clear()


async def execute_pipeline(
    user_message: str,
    registries: SystemRegistries,
    pipeline_manager: PipelineManager | None = None,
) -> Dict[str, Any]:
    state = PipelineState(
        conversation=[
            ConversationEntry(
                content=user_message, role="user", timestamp=datetime.now()
            )
        ],
        pipeline_id=generate_pipeline_id(),
        metrics=MetricsCollector(),
    )
    if pipeline_manager is not None:
        await pipeline_manager.register(state.pipeline_id)
    try:
        for stage in [
            PipelineStage.PARSE,
            PipelineStage.THINK,
            PipelineStage.DO,
            PipelineStage.REVIEW,
            PipelineStage.DELIVER,
        ]:
            await execute_stage(stage, state, registries)
            if state.failure_info:
                break

        if state.failure_info:
            try:
                await execute_stage(PipelineStage.ERROR, state, registries)
            except Exception:
                return create_static_error_response(state.pipeline_id)
            if state.response is None:
                return create_static_error_response(state.pipeline_id)
            return state.response
        if state.response is None:
            return create_default_response("No response generated", state.pipeline_id)
        return state.response
    finally:
        if pipeline_manager is not None:
            await pipeline_manager.deregister(state.pipeline_id)


async def execute_pending_tools(
    state: PipelineState, registries: SystemRegistries
) -> Dict[ToolCall, Any]:
    results: Dict[ToolCall, Any] = {}
    for call in state.pending_tool_calls:
        tool = registries.tools.get(call.name)
        if not tool:
            error_msg = f"Error: tool {call.name} not found"
            state.stage_results[call.result_key] = error_msg
            results[call] = error_msg
            continue

        try:
            tool = cast(Any, tool)
            if hasattr(tool, "execute_function_with_retry"):
                result = await tool.execute_function_with_retry(call.params)
            elif hasattr(tool, "execute_function"):
                result = await tool.execute_function(call.params)
            else:
                func = getattr(tool, "run", None)
                if func is None:
                    raise RuntimeError("Tool lacks execution method")
                if asyncio.iscoroutinefunction(func):
                    result = await func(call.params)
                else:
                    result = func(call.params)
            state.stage_results[call.result_key] = result
            results[call] = result
            state.metrics.record_tool_execution(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                call.result_key,
                call.source,
            )
        except Exception as exc:
            err = f"Error: {exc}"
            state.stage_results[call.result_key] = err
            results[call] = err
            state.metrics.record_tool_error(
                call.name,
                str(state.current_stage),
                state.pipeline_id,
                str(exc),
            )
    return results
