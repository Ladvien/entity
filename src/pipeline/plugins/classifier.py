from __future__ import annotations

import inspect
<<<<<< codex/enhance-plugin-auto-detection-and-creation
from typing import Any, Dict, Optional, Type, cast

from ..base_plugins import BasePlugin, PromptPlugin, AdapterPlugin, ToolPlugin
from ..stages import PipelineStage

from .base import AutoGeneratedPlugin


class PluginClassifier:
    """Heuristically determine plugin stage and type."""

    STAGE_KEYWORDS: dict[PipelineStage, set[str]] = {
        PipelineStage.PARSE: {"parse", "validate", "check", "extract"},
        PipelineStage.THINK: {"think", "reason", "analyze", "plan", "decide"},
        PipelineStage.REVIEW: {"review", "filter", "moderate", "clean"},
        PipelineStage.DELIVER: {"send", "deliver", "output", "respond"},
        PipelineStage.DO: {
            "return",
            "response",
            "answer",
            "fetch",
            "call",
            "execute",
            "compute",
        },
    }

    @classmethod
    def classify(
        cls, func: Any, hints: Optional[Dict[str, Any]] | None = None
    ) -> AutoGeneratedPlugin:
        """Return an :class:`AutoGeneratedPlugin` for ``func``."""

        hints = hints or {}
        try:
            source = inspect.getsource(func)
        except OSError:
            source = ""

        text = f"{func.__name__}\n{func.__doc__ or ''}\n{source}".lower()

        stage = PipelineStage.DO
        base: Type[BasePlugin] = ToolPlugin
        for candidate, keywords in cls.STAGE_KEYWORDS.items():
            if any(k in text for k in keywords):
                stage = candidate
                if candidate == PipelineStage.PARSE:
                    base = AdapterPlugin
                elif candidate == PipelineStage.THINK:
                    base = PromptPlugin
                elif candidate in {PipelineStage.REVIEW, PipelineStage.DELIVER}:
                    base = PromptPlugin
                else:
                    base = (
                        ToolPlugin
                        if any(x in text for x in ["use_tool", "execute_tool", "tool"])
                        else PromptPlugin
                    )
                break

        if "stage" in hints:
            stage = PipelineStage.from_str(str(hints["stage"]))
        priority = int(hints.get("priority", 50))
        name = hints.get("name", func.__name__)

        return AutoGeneratedPlugin(
            func=func,
            stages=[stage],
            priority=priority,
            name=name,
            base_class=cast(Type[BasePlugin], base),
        )

    @classmethod
    def classify_and_route(
        cls, func: Any, hints: Optional[Dict[str, Any]] | None = None
    ) -> AutoGeneratedPlugin:
        """Backward-compatible wrapper for :meth:`classify`."""

        return cls.classify(func, hints)
=======
from typing import Any, Dict, Optional, cast

from ..stages import PipelineStage
from ..base_plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    BasePlugin,
    PromptPlugin,
    ToolPlugin,
)


class PluginAutoClassifier:
    """Utility to generate plugin classes from async functions."""

    @staticmethod
    def classify(
        plugin_func: Any, user_hints: Optional[Dict[str, Any]] | None = None
    ) -> AutoGeneratedPlugin:
        """Classify ``plugin_func`` and return an :class:`AutoGeneratedPlugin`."""

        if not inspect.iscoroutinefunction(plugin_func):
            raise TypeError(
                f"Plugin function '{getattr(plugin_func, '__name__', 'unknown')}' must be async"
            )

        hints = user_hints or {}
        try:
            source = inspect.getsource(plugin_func)
        except OSError:
            source = ""

        base: type[BasePlugin]
        if any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            base = cast(type[BasePlugin], PromptPlugin)
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            base = cast(type[BasePlugin], AdapterPlugin)
        elif any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            base = (
                cast(type[BasePlugin], ToolPlugin)
                if any(x in source for x in ["use_tool", "execute_tool", "tool"])
                else cast(type[BasePlugin], PromptPlugin)
            )
        else:
            stage = PipelineStage.DO
            base = cast(type[BasePlugin], ToolPlugin)

        if "stage" in hints:
            stage = PipelineStage.from_str(str(hints["stage"]))

        priority = int(hints.get("priority", 50))
        name = hints.get("name", plugin_func.__name__)

        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=name,
            base_class=base,
        )

    @staticmethod
    def classify_and_route(
        plugin_func: Any, user_hints: Optional[Dict[str, Any]] | None = None
    ) -> AutoGeneratedPlugin:
        """Backward-compatible wrapper for :meth:`classify`."""

        return PluginAutoClassifier.classify(plugin_func, user_hints)
>>>>>> main
