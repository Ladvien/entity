from __future__ import annotations

<<<<<< codex/enhance-plugin-auto-detection-and-creation
from typing import Any, List, Optional

from ..base_plugins import (
    AutoGeneratedPlugin as _AutoGeneratedPlugin,
    BasePlugin,
    PromptPlugin,
    AdapterPlugin,
    ToolPlugin,
)
from ..stages import PipelineStage


class AutoGeneratedPlugin(_AutoGeneratedPlugin):
    """Wrapper for auto-generated plugins exposed under ``pipeline.plugins``."""

    def __init__(
        self,
        func: Any,
        stages: List[PipelineStage],
        priority: int,
        name: str,
        base_class: Optional[type] = None,
    ) -> None:
        super().__init__(
            func=func,
            stages=stages,
            priority=priority,
            name=name,
            base_class=base_class,
        )
======
from typing import TYPE_CHECKING, Dict, Type

from ..validation import ValidationResult
from ..base_plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    ConfigurationError,
    FailurePlugin,
    PromptPlugin,
    ReconfigResult,
    ResourcePlugin,
    ToolPlugin,
    BasePlugin as _BasePlugin,
)

if TYPE_CHECKING:  # pragma: no cover - used for type hints only
    from ..initializer import ClassRegistry


class BasePlugin(_BasePlugin):
    """Base plugin with validation hooks."""

    @classmethod
    def validate_config(cls: Type["BasePlugin"], config: Dict) -> ValidationResult:
        return ValidationResult.success_result()

    @classmethod
    def validate_dependencies(
        cls: Type["BasePlugin"], registry: "ClassRegistry"
    ) -> ValidationResult:
        return ValidationResult.success_result()


__all__ = [
    "BasePlugin",
    "ResourcePlugin",
    "ToolPlugin",
    "PromptPlugin",
    "AdapterPlugin",
    "FailurePlugin",
    "AutoGeneratedPlugin",
    "ReconfigResult",
    "ConfigurationError",
]
>>>>>> main
