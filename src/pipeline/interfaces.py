from __future__ import annotations

import inspect
from importlib import import_module
from typing import TYPE_CHECKING, Any, Dict, Optional, cast

if TYPE_CHECKING:  # pragma: no cover
    from .base_plugins import AutoGeneratedPlugin, BasePlugin


def import_plugin_class(path: str) -> type["BasePlugin"]:
    """Import plugin class from ``path``.

    The path should be ``module.submodule:ClassName`` or ``package.module.Class``.
    """
    if ":" in path:
        module_path, class_name = path.split(":", 1)
    elif "." in path:
        module_path, class_name = path.rsplit(".", 1)
    else:
        raise ValueError(f"Invalid plugin path: {path}")

    module = import_module(module_path)
    return getattr(module, class_name)


class PluginAutoClassifier:
    """Utility to generate plugin classes from async functions."""

    @staticmethod
    def classify(
        plugin_func: Any, user_hints: Optional[Dict[str, Any]] | None = None
    ) -> "AutoGeneratedPlugin":
        from .base_plugins import (
            AdapterPlugin,
            AutoGeneratedPlugin,
            BasePlugin,
            PromptPlugin,
        )
        from .stages import PipelineStage

        if not inspect.iscoroutinefunction(plugin_func):
            raise TypeError(
                f"Plugin function '{getattr(plugin_func, '__name__', 'unknown')}' must be async"
            )

        hints = user_hints or {}
        try:
            source = inspect.getsource(plugin_func)
        except OSError:
            source = ""

        base: type[BasePlugin]
        if any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            base = cast(type[BasePlugin], PromptPlugin)
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            base = cast(type[BasePlugin], AdapterPlugin)
        elif any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            base = cast(type[BasePlugin], PromptPlugin)
        else:
            stage = PipelineStage.DO
            base = cast(type[BasePlugin], PromptPlugin)

        if "stage" in hints:
            stage = PipelineStage.from_str(str(hints["stage"]))

        priority = int(hints.get("priority", 50))
        name = hints.get("name", plugin_func.__name__)

        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=name,
            base_class=base,
        )

    @staticmethod
    def classify_and_route(
        plugin_func: Any, user_hints: Optional[Dict[str, Any]] | None = None
    ) -> "AutoGeneratedPlugin":
        """Backward-compatible wrapper for :meth:`classify`."""

        return PluginAutoClassifier.classify(plugin_func, user_hints)


__all__ = ["PluginAutoClassifier", "import_plugin_class"]
