from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional

from .stages import PipelineStage


@dataclass
class LLMResponse:
    """Result returned by an LLM call.

    Attributes:
        content: Text generated by the model.
        metadata: Provider-specific metadata about the call.
    """

    content: str
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ConversationEntry:
    """Single message stored in the conversation history.

    Attributes:
        content: Message text.
        role: Speaker role (e.g. ``user`` or ``assistant``).
        timestamp: When the message was created.
        metadata: Extra data recorded with the entry.
    """

    content: str
    role: str
    timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass(eq=False)
class ToolCall:
    """Description of a tool execution request.

    Attributes:
        name: Registry key of the tool to run.
        params: Parameters passed to the tool.
        result_key: Key used to store the tool result.
        source: Origin of the call (direct or generated).
    """

    name: str
    params: Dict[str, Any]
    result_key: str
    source: str = "direct_execution"


@dataclass
class FailureInfo:
    """Captured information about a pipeline failure.

    Attributes:
        stage: Stage in which the error occurred.
        plugin_name: Plugin reporting the failure.
        error_type: Name of the raised exception class.
        error_message: Human readable description.
        original_exception: Original exception instance.
        context_snapshot: Optional snapshot of pipeline state.
        timestamp: When the failure was recorded.
    """

    stage: str
    plugin_name: str
    error_type: str
    error_message: str
    original_exception: Exception
    context_snapshot: Dict[str, Any] | None = None
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class MetricsCollector:
    """Accumulates runtime metrics for a single pipeline run.

    Attributes:
        pipeline_durations: Execution times for each run.
        plugin_durations: Execution times per plugin and stage.
        tool_execution_count: Count of tool executions.
        tool_error_count: Count of tool failures.
        llm_call_count: Count of LLM calls by stage and plugin.
    """

    pipeline_durations: list[float] = field(default_factory=list)
    plugin_durations: dict[str, list[float]] = field(default_factory=dict)
    tool_execution_count: dict[str, int] = field(default_factory=dict)
    tool_error_count: dict[str, int] = field(default_factory=dict)
    llm_call_count: dict[str, int] = field(default_factory=dict)
    llm_durations: dict[str, list[float]] = field(default_factory=dict)

    def record_pipeline_duration(self, duration: float) -> None:
        self.pipeline_durations.append(duration)

    def record_plugin_duration(self, plugin: str, stage: str, duration: float) -> None:
        key = f"{stage}:{plugin}"
        self.plugin_durations.setdefault(key, []).append(duration)

    def record_tool_execution(
        self, tool_name: str, stage: str, pipeline_id: str, result_key: str, source: str
    ) -> None:
        key = f"{stage}:{tool_name}"
        self.tool_execution_count[key] = self.tool_execution_count.get(key, 0) + 1

    def record_tool_error(
        self, tool_name: str, stage: str, pipeline_id: str, error: str
    ) -> None:
        key = f"{stage}:{tool_name}"
        self.tool_error_count[key] = self.tool_error_count.get(key, 0) + 1

    def record_llm_call(self, plugin: str, stage: str, purpose: str) -> None:
        key = f"{stage}:{plugin}:{purpose}"
        self.llm_call_count[key] = self.llm_call_count.get(key, 0) + 1

    def record_llm_duration(self, plugin: str, stage: str, duration: float) -> None:
        key = f"{stage}:{plugin}"
        self.llm_durations.setdefault(key, []).append(duration)

    def to_dict(self) -> dict[str, Any]:
        return {
            "pipeline_durations": self.pipeline_durations,
            "plugin_durations": self.plugin_durations,
            "tool_execution_count": self.tool_execution_count,
            "tool_error_count": self.tool_error_count,
            "llm_call_count": self.llm_call_count,
            "llm_durations": self.llm_durations,
        }


@dataclass
class PipelineState:
    """Mutable state shared across pipeline stages.

    This object is created at the start of each pipeline run and is
    passed to every plugin.

    Attributes:
        conversation: History of conversation messages.
        response: Final response to return to the caller.
        prompt: Prompt text currently being processed.
        stage_results: Values produced during stage execution.
        pending_tool_calls: Tool calls awaiting execution.
        metadata: Arbitrary per-run metadata for plugins.
        pipeline_id: Unique identifier for this run.
        current_stage: Stage that is currently executing.
        metrics: Collector used to record runtime metrics.
        failure_info: Details about any failure encountered.
    """

    conversation: List[ConversationEntry]
    response: Any = None
    prompt: str = ""
    stage_results: Dict[str, Any] = field(default_factory=dict)
    pending_tool_calls: List[ToolCall] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    pipeline_id: str = ""
    current_stage: Optional[PipelineStage] = None
    metrics: MetricsCollector = field(default_factory=MetricsCollector)
    failure_info: Optional[FailureInfo] = None
