from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from types import ModuleType
from typing import Any, Callable, Optional

from common_interfaces import plugins as plugin_utils
from common_interfaces.base_plugin import BasePlugin as BasePluginInterface
from registry import PluginRegistry, ResourceContainer, SystemRegistries, ToolRegistry

from .base_plugins import AdapterPlugin, AutoGeneratedPlugin
from .base_plugins import BasePlugin as BasePluginType
from .base_plugins import PromptPlugin
from .interfaces import PluginAutoClassifier
from .logging import get_logger
from .runtime import AgentRuntime
from .user_plugins import BasePlugin

logger = get_logger(__name__)


@dataclass
class AgentBuilder:
    """Collect plugins and build :class:`AgentRuntime`."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceContainer = field(default_factory=ResourceContainer)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)

    def __post_init__(self) -> None:
        """Configure plugin system on first construction."""
        if plugin_utils.AutoGeneratedPluginType is object:
            plugin_utils.configure_plugins(
                BasePluginType,
                PromptPlugin,
                AdapterPlugin,
                AutoGeneratedPlugin,
            )

    # ------------------------------ plugin utils ------------------------------
    def add_plugin(self, plugin: BasePlugin) -> None:
        """Validate and register ``plugin`` for its declared stages."""

        if not hasattr(plugin, "_execute_impl") or not callable(
            getattr(plugin, "_execute_impl")
        ):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            raise TypeError(f"Plugin '{name}' must implement async '_execute_impl'")
        for stage in getattr(plugin, "stages", []):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            result = self.plugin_registry.register_plugin_for_stage(plugin, stage, name)
            if asyncio.iscoroutine(result):
                asyncio.run(result)

    def plugin(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a plugin."""

        def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
            plugin = PluginAutoClassifier.classify(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    # ---------------------------- discovery helpers ---------------------------
    @classmethod
    def from_directory(cls, directory: str) -> "AgentBuilder":
        builder = cls()
        builder.load_plugins_from_directory(directory)
        return builder

    @classmethod
    def from_package(cls, package_name: str) -> "AgentBuilder":
        builder = cls()
        builder.load_plugins_from_package(package_name)
        return builder

    def load_plugins_from_directory(self, directory: str) -> None:
        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def load_plugins_from_package(self, package_name: str) -> None:
        import importlib
        import pkgutil

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            self._register_module_plugins(package)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to import plugin module %s: %s",
                    info.name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
            self._register_module_plugins(module)

    # ------------------------------ runtime build -----------------------------
    def build_runtime(self) -> "AgentRuntime":
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return AgentRuntime(registries)

    # ------------------------------ internals --------------------------------
    def _import_module(self, file: Path) -> ModuleType | None:
        import importlib.util

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception as exc:  # noqa: BLE001
            logger.error(
                "Failed to import plugin module %s: %s",
                file,
                exc,
                extra={"pipeline_id": "builder", "stage": "initialization"},
            )
            return None

    def _register_module_plugins(self, module: ModuleType) -> None:
        import inspect

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and (
                        issubclass(obj, BasePlugin)
                        or issubclass(obj, BasePluginInterface)
                    )
                    and obj not in {BasePlugin, BasePluginInterface}
                ):
                    try:
                        instance = obj()
                    except TypeError:
                        instance = obj({})
                    self.add_plugin(instance)
                elif callable(obj) and hasattr(obj, "__entity_plugin__"):
                    self.add_plugin(getattr(obj, "__entity_plugin__"))
                elif callable(obj) and name.endswith("_plugin"):
                    self.plugin(obj)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to register plugin from %s.%s: %s",
                    module.__name__,
                    name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
