from __future__ import annotations

from typing import Any, Callable, Dict, Optional

from .pipeline import SystemRegistries, execute_pipeline
from .plugins import AutoGeneratedPlugin, PromptPlugin
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage


class Agent:
    """Minimal agent with plugin decorator and pipeline execution."""

    def __init__(self) -> None:
        self.plugins = PluginRegistry()
        self.resources = ResourceRegistry()
        self.tools = ToolRegistry()

    def plugin(
        self,
        func: Optional[Callable] = None,
        *,
        stage: Optional[PipelineStage] = None,
        priority: int = 50,
        base_class: type = PromptPlugin,
    ) -> Callable:
        """Decorator to register a function as a plugin."""

        def wrapper(fn: Callable) -> Callable:
            assigned_stage = stage or self._auto_stage(fn)
            plugin = AutoGeneratedPlugin(
                fn, [assigned_stage], priority, fn.__name__, base_class
            )
            self.plugins.register_plugin_for_stage(plugin, assigned_stage)
            return fn

        return wrapper(func) if func else wrapper

    def _auto_stage(self, func: Callable) -> PipelineStage:
        name = func.__name__.lower()
        if "parse" in name:
            return PipelineStage.PARSE
        if "think" in name:
            return PipelineStage.THINK
        if "review" in name:
            return PipelineStage.REVIEW
        if "deliver" in name:
            return PipelineStage.DELIVER
        return PipelineStage.DO

    async def run_message(self, message: str) -> Dict[str, Any]:
        registries = SystemRegistries(
            resources=self.resources, tools=self.tools, plugins=self.plugins
        )
        return await execute_pipeline(message, registries)
