from __future__ import annotations

import asyncio
import inspect
import json
from dataclasses import dataclass
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any, Callable, Dict, Optional

from .pipeline import SystemRegistries, execute_pipeline
from .plugins import AdapterPlugin, AutoGeneratedPlugin, PromptPlugin, ToolPlugin
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage


class PluginAutoClassifier:
    """Classify a function and generate a plugin instance."""

    @staticmethod
    def classify_and_route(
        plugin_func: Callable,
        user_hints: Optional[Dict[str, Any]] = None,
    ) -> AutoGeneratedPlugin:
        """Create :class:`AutoGeneratedPlugin` from ``plugin_func``."""
        user_hints = user_hints or {}
        source = inspect.getsource(plugin_func)

        if any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            plugin_type = (
                ToolPlugin
                if any(w in source for w in ["tool", "use_tool"])
                else PromptPlugin
            )
        elif any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            plugin_type = PromptPlugin
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            plugin_type = AdapterPlugin
        else:
            stage = PipelineStage.DO
            plugin_type = ToolPlugin

        if "stage" in user_hints and user_hints["stage"]:
            hint = user_hints["stage"]
            stage = PipelineStage.from_str(hint) if isinstance(hint, str) else hint

        priority = int(user_hints.get("priority", 50))
        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=plugin_func.__name__,
            base_class=plugin_type,
        )


@dataclass
class Agent:
    """Simple agent wrapper for plugin registries."""

    plugin_registry: PluginRegistry = PluginRegistry()
    resource_registry: ResourceRegistry = ResourceRegistry()
    tool_registry: ToolRegistry = ToolRegistry()

    def add_plugin(self, plugin: Any) -> None:
        """Register a plugin instance for its stages."""
        for stage in getattr(plugin, "stages", []):
            self.plugin_registry.register_plugin_for_stage(plugin, stage)

    def plugin(self, func: Optional[Callable] = None, **hints):
        """Decorator to register function as plugin."""

        def decorator(f: Callable) -> Callable:
            plugin = PluginAutoClassifier.classify_and_route(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    def _create_server(self, host: str, port: int) -> HTTPServer:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )

        class Handler(BaseHTTPRequestHandler):
            def do_POST(self) -> None:  # noqa: N802 - http server naming
                length = int(self.headers.get("Content-Length", "0"))
                body = self.rfile.read(length).decode("utf-8")
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    self.send_response(400)
                    self.end_headers()
                    self.wfile.write(b"Invalid JSON")
                    return
                message = data.get("message", "")
                response = asyncio.run(execute_pipeline(message, registries))
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps(response).encode("utf-8"))

        return HTTPServer((host, port), Handler)

    def run(self, host: str = "localhost", port: int = 8000) -> None:
        """Launch a minimal HTTP adapter for the agent."""
        server = self._create_server(host, port)
        print(f"Serving on http://{host}:{port}")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass
        finally:
            server.server_close()
