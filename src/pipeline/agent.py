from __future__ import annotations

import asyncio
import inspect
import json
import importlib.util
import sys
from dataclasses import dataclass, field
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from typing import Any, Callable, Dict, Optional

from .pipeline import SystemRegistries, execute_pipeline
from .plugins import (AdapterPlugin, AutoGeneratedPlugin, PromptPlugin,
                      ToolPlugin)
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage


class PluginAutoClassifier:
    """Classify a function and generate a plugin instance."""

    @staticmethod
    def classify_and_route(
        plugin_func: Callable,
        user_hints: Optional[Dict[str, Any]] = None,
    ) -> AutoGeneratedPlugin:
        """Create :class:`AutoGeneratedPlugin` from ``plugin_func``."""
        user_hints = user_hints or {}
        source = inspect.getsource(plugin_func)

        if any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            plugin_type = PromptPlugin
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            plugin_type = AdapterPlugin
        elif any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            plugin_type = (
                ToolPlugin
                if any(w in source for w in ["tool", "use_tool"])
                else PromptPlugin
            )
        else:
            stage = PipelineStage.DO
            plugin_type = ToolPlugin

        if "stage" in user_hints and user_hints["stage"]:
            hint = user_hints["stage"]
            stage = PipelineStage.from_str(hint) if isinstance(hint, str) else hint

        priority = int(user_hints.get("priority", 50))
        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=plugin_func.__name__,
            base_class=plugin_type,
        )


@dataclass
class Agent:
    """Minimal agent with plugin decorator and pipeline execution."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceRegistry = field(default_factory=ResourceRegistry)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)

    # Backwards compatibility aliases
    @property
    def plugins(self) -> PluginRegistry:
        return self.plugin_registry

    @property
    def resources(self) -> ResourceRegistry:
        return self.resource_registry

    @property
    def tools(self) -> ToolRegistry:
        return self.tool_registry

    @classmethod
    def from_directory(cls, directory: str) -> "Agent":
        """Create an agent and automatically register plugins from ``directory``."""
        agent = cls()
        for path in Path(directory).glob("*.py"):
            module_name = path.stem
            spec = importlib.util.spec_from_file_location(module_name, path)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module
                spec.loader.exec_module(module)
                for _, obj in inspect.getmembers(module, inspect.isfunction):
                    agent.plugin(obj)
        return agent

    def add_plugin(self, plugin: Any) -> None:
        """Register a plugin instance for its stages."""
        for stage in getattr(plugin, "stages", []):
            self.plugin_registry.register_plugin_for_stage(plugin, stage)

    def plugin(self, func: Optional[Callable] = None, **hints):
        """Decorator to register a function as a plugin."""

        def decorator(f: Callable) -> Callable:
            plugin = PluginAutoClassifier.classify_and_route(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    def _create_server(self, host: str, port: int) -> HTTPServer:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )

        class Handler(BaseHTTPRequestHandler):
            def do_POST(self) -> None:  # noqa: N802 - http server naming
                length = int(self.headers.get("Content-Length", "0"))
                body = self.rfile.read(length).decode("utf-8")
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    self.send_response(400)
                    self.end_headers()
                    self.wfile.write(b"Invalid JSON")
                    return
                message = data.get("message", "")
                response = asyncio.run(execute_pipeline(message, registries))
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps(response).encode("utf-8"))

        return HTTPServer((host, port), Handler)

    def run(self, host: str = "localhost", port: int = 8000) -> None:
        """Launch a minimal HTTP adapter for the agent."""
        server = self._create_server(host, port)
        print(f"Serving on http://{host}:{port}")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass
        finally:
            server.server_close()

    async def run_message(self, message: str) -> Dict[str, Any]:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return await execute_pipeline(message, registries)
