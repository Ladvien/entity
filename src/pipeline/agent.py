from __future__ import annotations

import asyncio
import importlib.util
import inspect
import json
import logging
from dataclasses import dataclass, field
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from types import ModuleType
import sys
from dataclasses import dataclass, field
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path

from typing import Any, Callable, Dict, Optional

from .pipeline import SystemRegistries, execute_pipeline
from .plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    BasePlugin,
    PromptPlugin,
    ToolPlugin,
)
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage

logger = logging.getLogger(__name__)


class PluginAutoClassifier:
    """Classify a function and generate a plugin instance."""

    @staticmethod
    def classify_and_route(
        plugin_func: Callable,
        user_hints: Optional[Dict[str, Any]] = None,
    ) -> AutoGeneratedPlugin:
        """Create :class:`AutoGeneratedPlugin` from ``plugin_func``."""
        user_hints = user_hints or {}
        source = inspect.getsource(plugin_func)

        if any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            plugin_type = PromptPlugin
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            plugin_type = AdapterPlugin
        elif any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            plugin_type = (
                ToolPlugin
                if any(w in source for w in ["tool", "use_tool"])
                else PromptPlugin
            )
        else:
            stage = PipelineStage.DO
            plugin_type = ToolPlugin

        if "stage" in user_hints and user_hints["stage"]:
            hint = user_hints["stage"]
            stage = PipelineStage.from_str(hint) if isinstance(hint, str) else hint

        priority = int(user_hints.get("priority", 50))
        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=plugin_func.__name__,
            base_class=plugin_type,
        )


@dataclass
class Agent:
    """Minimal agent with plugin decorator and pipeline execution."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceRegistry = field(default_factory=ResourceRegistry)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)

    # Backwards compatibility aliases
    @property
    def plugins(self) -> PluginRegistry:
        return self.plugin_registry

    @property
    def resources(self) -> ResourceRegistry:
        return self.resource_registry

    @property
    def tools(self) -> ToolRegistry:
        return self.tool_registry

    @classmethod
    def from_directory(cls, directory: str) -> "Agent":
        """Create an agent and automatically register plugins from ``directory``."""
        agent = cls()
        for path in Path(directory).glob("*.py"):
            module_name = path.stem
            spec = importlib.util.spec_from_file_location(module_name, path)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module
                spec.loader.exec_module(module)
                for _, obj in inspect.getmembers(module, inspect.isfunction):
                    agent.plugin(obj)
        return agent

    def add_plugin(self, plugin: Any) -> None:
        """Register a plugin instance for its stages."""
        for stage in getattr(plugin, "stages", []):
            self.plugin_registry.register_plugin_for_stage(plugin, stage)

    def plugin(self, func: Optional[Callable] = None, **hints):
        """Decorator to register a function as a plugin."""

        def decorator(f: Callable) -> Callable:
            plugin = PluginAutoClassifier.classify_and_route(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    # ------------------------------------------------------------------
    # Plugin loading utilities
    # ------------------------------------------------------------------

    @classmethod
    def from_directory(cls, directory: str) -> "Agent":
        """Create an agent and load plugins from ``directory``.

        Plugin modules that fail to import are logged and ignored.
        """

        agent = cls()
        agent.load_plugins_from_directory(directory)
        return agent

    def load_plugins_from_directory(self, directory: str) -> None:
        """Load plugin modules from ``directory``."""

        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def _import_module(self, file: Path) -> ModuleType | None:
        """Import ``file`` and return the loaded module or ``None`` on error."""

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to import plugin module %s: %s", file, exc)
            return None

    def _register_module_plugins(self, module: ModuleType) -> None:
        """Register plugins defined in ``module``."""

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and issubclass(obj, BasePlugin)
                    and obj is not BasePlugin
                ):
                    self.add_plugin(obj({}))
                elif callable(obj):
                    self.plugin(obj)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to register plugin %s from %s: %s",
                    name,
                    getattr(module, "__file__", "<unknown>"),
                    exc,
                )

    def _create_server(self, host: str, port: int) -> HTTPServer:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )

        class Handler(BaseHTTPRequestHandler):
            def do_POST(self) -> None:  # noqa: N802 - http server naming
                length = int(self.headers.get("Content-Length", "0"))
                body = self.rfile.read(length).decode("utf-8")
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    self.send_response(400)
                    self.end_headers()
                    self.wfile.write(b"Invalid JSON")
                    return
                message = data.get("message", "")
                response = asyncio.run(execute_pipeline(message, registries))
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps(response).encode("utf-8"))

        return HTTPServer((host, port), Handler)

    def run(self, host: str = "localhost", port: int = 8000) -> None:
        """Launch a minimal HTTP adapter for the agent."""
        server = self._create_server(host, port)
        print(f"Serving on http://{host}:{port}")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass
        finally:
            server.server_close()

    async def run_message(self, message: str) -> Dict[str, Any]:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return await execute_pipeline(message, registries)
