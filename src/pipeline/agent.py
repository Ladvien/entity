from __future__ import annotations
from typing import Any, Callable, Dict, Optional

from typing import Any, Callable, Dict

from .pipeline import SystemRegistries, execute_pipeline
from .plugins import BasePlugin, PluginAutoClassifier
from .registry import PluginRegistry, ResourceRegistry, ToolRegistry
from .stages import PipelineStage
from .pipeline import SystemRegistries, execute_pipeline
from .plugins import AutoGeneratedPlugin, PromptPlugin

class Agent:
    """Minimal agent with plugin decorator and pipeline execution."""

    def __init__(self) -> None:
        self.plugins = PluginRegistry()
        self.resources = ResourceRegistry()
        self.tools = ToolRegistry()

    def plugin(
        self,
        func: Optional[Callable] = None,
        *,
        stage: Optional[PipelineStage] = None,
        priority: int = 50,
        base_class: type = PromptPlugin,
    ) -> Callable:
        """Decorator to register a function as a plugin."""

        def wrapper(fn: Callable) -> Callable:
            assigned_stage = stage or self._auto_stage(fn)
            plugin = AutoGeneratedPlugin(
                fn, [assigned_stage], priority, fn.__name__, base_class
            )
            self.plugins.register_plugin_for_stage(plugin, assigned_stage)
            return fn

        return wrapper(func) if func else wrapper

    def _auto_stage(self, func: Callable) -> PipelineStage:
        name = func.__name__.lower()
        if "parse" in name:
            return PipelineStage.PARSE
        if "think" in name:
            return PipelineStage.THINK
        if "review" in name:
            return PipelineStage.REVIEW
        if "deliver" in name:
            return PipelineStage.DELIVER
        return PipelineStage.DO

    async def run_message(self, message: str) -> Dict[str, Any]:
        registries = SystemRegistries(
            resources=self.resources, tools=self.tools, plugins=self.plugins
        )
        return await execute_pipeline(message, registries)

    """Simple agent for registering plugins and executing a pipeline."""

    def __init__(self) -> None:
        self.registries = SystemRegistries(
            resources=ResourceRegistry(), tools=ToolRegistry(), plugins=PluginRegistry()
        )

    # ------------------------------------------------------------------
    def plugin(self, **hints: Any) -> Callable[[Callable], Callable]:
        """Decorator to register a function as a plugin."""

        def decorator(func: Callable) -> Callable:
            plugin = PluginAutoClassifier.classify(func, hints)
            for stage in plugin.stages:
                self.registries.plugins.register_plugin_for_stage(plugin, stage)
            return func

        return decorator

    def add_plugin(self, plugin: BasePlugin) -> None:
        for stage in getattr(plugin, "stages", [PipelineStage.DO]):
            self.registries.plugins.register_plugin_for_stage(plugin, stage)

    async def run_pipeline(self, user_message: str) -> Dict[str, Any]:
        return await execute_pipeline(user_message, self.registries)

    def run(self) -> None:
        raise NotImplementedError("Server functionality is not implemented")

