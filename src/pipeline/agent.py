from __future__ import annotations

import asyncio
import importlib
import importlib.util
import inspect
import json
import logging
import pkgutil
from dataclasses import dataclass, field
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from types import ModuleType
from typing import Any, Callable, Dict, Optional, cast

from .pipeline import execute_pipeline
from .plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    BasePlugin,
    PromptPlugin,
    ToolPlugin,
)
from .registries import PluginRegistry, ResourceRegistry, SystemRegistries, ToolRegistry
from .stages import PipelineStage

logger = logging.getLogger(__name__)


class PluginAutoClassifier:
    """Classify a function and generate a plugin instance."""

    @staticmethod
    def classify_and_route(
        plugin_func: Callable,
        user_hints: Optional[Dict[str, Any]] = None,
    ) -> AutoGeneratedPlugin:
        """Create :class:`AutoGeneratedPlugin` from ``plugin_func``."""
        user_hints = user_hints or {}
        source = inspect.getsource(plugin_func)

        plugin_type: type[BasePlugin]
        if any(k in source for k in ["think", "reason", "analyze"]):
            stage = PipelineStage.THINK
            plugin_type = cast(type[BasePlugin], PromptPlugin)
        elif any(k in source for k in ["parse", "validate", "check"]):
            stage = PipelineStage.PARSE
            plugin_type = cast(type[BasePlugin], AdapterPlugin)
        elif any(k in source for k in ["return", "response", "answer"]):
            stage = PipelineStage.DO
            plugin_type = (
                cast(type[BasePlugin], ToolPlugin)
                if any(w in source for w in ["tool", "use_tool"])
                else cast(type[BasePlugin], PromptPlugin)
            )
        else:
            stage = PipelineStage.DO
            plugin_type = cast(type[BasePlugin], ToolPlugin)

        if "stage" in user_hints and user_hints["stage"]:
            hint = user_hints["stage"]
            stage = PipelineStage.from_str(hint) if isinstance(hint, str) else hint

        priority = int(user_hints.get("priority", 50))
        return AutoGeneratedPlugin(
            func=plugin_func,
            stages=[stage],
            priority=priority,
            name=plugin_func.__name__,
            base_class=plugin_type,
        )


@dataclass
class Agent:
    """Minimal agent with plugin decorator and pipeline execution."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceRegistry = field(default_factory=ResourceRegistry)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)

    # Backwards compatibility aliases
    @property
    def plugins(self) -> PluginRegistry:
        return self.plugin_registry

    @property
    def resources(self) -> ResourceRegistry:
        return self.resource_registry

    @property
    def tools(self) -> ToolRegistry:
        return self.tool_registry

    def add_plugin(self, plugin: Any) -> None:
        """Register a plugin instance for its stages."""
        for stage in getattr(plugin, "stages", []):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            self.plugin_registry.register_plugin_for_stage(plugin, stage, name)

    def plugin(self, func: Optional[Callable] = None, **hints):
        """Decorator to register a function as a plugin."""

        def decorator(f: Callable) -> Callable:
            plugin = PluginAutoClassifier.classify_and_route(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    # ------------------------------------------------------------------
    # Plugin loading utilities
    # ------------------------------------------------------------------

    @classmethod
    def from_directory(cls, directory: str) -> "Agent":
        """Create an agent and load plugins from ``directory``.

        Plugin modules that fail to import are logged and ignored.
        """

        agent = cls()
        agent.load_plugins_from_directory(directory)
        return agent

    @classmethod
    def from_package(cls, package_name: str) -> "Agent":
        """Create an agent and load plugins from ``package_name``.

        All modules within the package are imported and scanned for plugin
        objects. Modules that fail to import are logged and skipped.
        """

        agent = cls()
        agent.load_plugins_from_package(package_name)
        return agent

    def load_plugins_from_directory(self, directory: str) -> None:
        """Load plugin modules from ``directory``."""

        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def load_plugins_from_package(self, package_name: str) -> None:
        """Load plugin modules from a package and its submodules."""

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            self._register_module_plugins(package)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception as exc:  # noqa: BLE001
                logger.error("Failed to import plugin module %s: %s", info.name, exc)
                continue
            self._register_module_plugins(module)

    def _import_module(self, file: Path) -> ModuleType | None:
        """Import ``file`` and return the loaded module or ``None`` on error."""

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to import plugin module %s: %s", file, exc)
            return None

    def _register_module_plugins(self, module: ModuleType) -> None:
        """Register plugins defined in ``module``."""

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and issubclass(obj, BasePlugin)
                    and obj is not BasePlugin
                ):
                    self.add_plugin(obj({}))
                elif callable(obj) and name.endswith("_plugin"):
                    self.plugin(obj)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to register plugin %s from %s: %s",
                    name,
                    getattr(module, "__file__", "<unknown>"),
                    exc,
                )

    def _create_server(self, host: str, port: int) -> HTTPServer:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )

        class Handler(BaseHTTPRequestHandler):
            def do_POST(self) -> None:  # noqa: N802 - http server naming
                length = int(self.headers.get("Content-Length", "0"))
                body = self.rfile.read(length).decode("utf-8")
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    self.send_response(400)
                    self.end_headers()
                    self.wfile.write(b"Invalid JSON")
                    return
                message = data.get("message", "")
                response = asyncio.run(execute_pipeline(message, registries))
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps(response).encode("utf-8"))

        return HTTPServer((host, port), Handler)

    def run(self, host: str = "localhost", port: int = 8000) -> None:
        """Launch a minimal HTTP adapter for the agent."""
        server = self._create_server(host, port)
        print(f"Serving on http://{host}:{port}")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass
        finally:
            server.server_close()

    async def run_message(self, message: str) -> Dict[str, Any]:
        registries = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return cast(Dict[str, Any], await execute_pipeline(message, registries))
