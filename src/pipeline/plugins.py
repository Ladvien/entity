from __future__ import annotations

import asyncio
import inspect
import logging
import time
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

from .context import PluginContext, SimpleContext
from .stages import PipelineStage

logger = logging.getLogger(__name__)

class BasePlugin(ABC):
    stages: List[PipelineStage]
    priority: int = 50
    dependencies: List[str] = []

    async def execute(self, context: PluginContext | SimpleContext):
        logger.info(
            "Plugin execution started",
            extra={
                "plugin": self.__class__.__name__,
                "stage": str(context.current_stage),
                "pipeline_id": context.pipeline_id,
            },
        )
        start = time.time()
        try:
            result = await self._execute_impl(context)
            duration = time.time() - start
            logger.info(
                "Plugin execution finished",
                extra={
                    "plugin": self.__class__.__name__,
                    "stage": str(context.current_stage),
                    "duration": duration,
                },
            )
            return result
        except Exception as e:  # pragma: no cover - simple logging only
            logger.exception(
                "Plugin execution failed",
                extra={
                    "plugin": self.__class__.__name__,
                    "stage": str(context.current_stage),
                    "error": str(e),
                },
            )
            raise

    @abstractmethod
    async def _execute_impl(self, context: PluginContext | SimpleContext):
        pass


class ResourcePlugin(BasePlugin):
    pass


class ToolPlugin(BasePlugin):
    async def execute_function(self, params: Dict[str, Any]):
        raise NotImplementedError()

    async def execute_function_with_retry(self, params: Dict[str, Any], max_retries: int = 1, delay: float = 1.0):
        for attempt in range(max_retries + 1):
            try:
                return await self.execute_function(params)
            except Exception:
                if attempt == max_retries:
                    raise
                await asyncio.sleep(delay)


class PromptPlugin(BasePlugin):
    pass


class AdapterPlugin(BasePlugin):
    pass


class FailurePlugin(BasePlugin):
    pass


class AutoGeneratedPlugin(BasePlugin):
    def __init__(self, func, stages: List[PipelineStage], priority: int, name: str, base_class: Optional[type] = None):
        self.func = func
        self.stages = stages
        self.priority = priority
        self.name = name
        if base_class and base_class is not BasePlugin:
            self.__class__.__bases__ = (base_class,)

    async def _execute_impl(self, context: PluginContext | SimpleContext):
        if inspect.iscoroutinefunction(self.func):
            result = await self.func(context)
        else:
            result = self.func(context)
        if isinstance(result, str) and not context.has_response():
            context.set_response(result)
