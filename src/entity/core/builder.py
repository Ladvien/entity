"""Pipeline component: builder."""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from types import ModuleType
from typing import Any, Callable, Iterable, Mapping, Optional

from entity.core import plugin_utils
from entity.core.plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    Plugin,
    Plugin as PluginInterface,
    Plugin as PluginType,
    FailurePlugin,
    PromptPlugin,
    ResourcePlugin,
    ToolPlugin,
)
from entity.core.registries import PluginRegistry, SystemRegistries, ToolRegistry
from entity.core.resources.container import ResourceContainer
from entity.core.runtime import AgentRuntime
from entity.utils.logging import get_logger


from .plugin_utils import PluginAutoClassifier
from .stages import PipelineStage

logger = get_logger(__name__)


@dataclass
class _AgentBuilder:
    """Collect plugins and build :class:`AgentRuntime`."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceContainer = field(default_factory=ResourceContainer)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)
    _added_plugins: list[Plugin] = field(default_factory=list, init=False)

    # ------------------------------ utility helpers ------------------------------
    def has_plugin(self, name: str) -> bool:
        """Return True if a plugin, resource, or tool with ``name`` exists."""

        if self.plugin_registry.get_plugin(name) is not None:
            return True
        if self.resource_registry.get(name) is not None:
            return True
        if self.tool_registry.get(name) is not None:
            return True
        return False

    def __post_init__(self) -> None:
        """Configure plugin system on first construction."""
        if plugin_utils.plugin_base_registry.auto_plugin is object:
            plugin_utils.configure_plugins(
                PluginType,
                PromptPlugin,
                AdapterPlugin,
                AutoGeneratedPlugin,
                ToolPlugin,
                FailurePlugin,
                ResourcePlugin,
            )

    # ------------------------------ plugin utils ------------------------------
    def add_plugin(
        self, plugin: Plugin, config: Mapping[str, Any] | None = None
    ) -> None:
        """Validate and register ``plugin`` for its resolved stages."""

        if not hasattr(plugin, "_execute_impl") or not callable(
            getattr(plugin, "_execute_impl")
        ):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            raise TypeError(f"Plugin '{name}' must implement async '_execute_impl'")

        result = plugin.__class__.validate_config(plugin.config)
        if not result.success:
            raise SystemError(
                f"Config validation failed for {plugin.__class__.__name__}: {result.message}"
            )

        dep_result = plugin.__class__.validate_dependencies(self)
        if not dep_result.success:
            raise SystemError(
                f"Dependency validation failed for {plugin.__class__.__name__}: {dep_result.message}"
            )

        stages = self._resolve_plugin_stages(plugin, config)
        for stage in stages:
            name = getattr(plugin, "name", plugin.__class__.__name__)
            asyncio.run(
                self.plugin_registry.register_plugin_for_stage(plugin, stage, name)
            )

        self._added_plugins.append(plugin)

    def plugin(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a plugin."""

        def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
            if not (
                hints.get("plugin_class") or hints.get("stage") or hints.get("stages")
            ):
                raise ValueError("plugin() requires 'plugin_class' or stage hints")

            plugin = PluginAutoClassifier.classify(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    # ---------------------------- discovery helpers ---------------------------
    @classmethod
    def from_directory(cls, directory: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_directory(directory)
        return builder

    @classmethod
    def from_package(cls, package_name: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_package(package_name)
        return builder

    def load_plugins_from_directory(self, directory: str) -> None:
        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def load_plugins_from_package(self, package_name: str) -> None:
        import importlib
        import pkgutil

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            self._register_module_plugins(package)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to import plugin module %s: %s",
                    info.name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
            self._register_module_plugins(module)

    # ------------------------------ config helpers -----------------------------
    @classmethod
    def from_yaml(cls, yaml_path: str) -> "_AgentBuilder":
        """Create a builder from a YAML configuration file."""

        import yaml

        with open(yaml_path, "r", encoding="utf-8") as handle:
            data = yaml.safe_load(handle) or {}
        builder = cls()
        builder.load_from_dict(data)
        return builder

    def load_from_dict(self, cfg: Mapping[str, Any]) -> None:
        """Register plugins from a configuration mapping in listed order."""

        plugins_cfg = cfg.get("plugins", {})
        for section, entries in plugins_cfg.items():
            if not isinstance(entries, Mapping):
                continue
            for name, meta in entries.items():
                if isinstance(meta, str):
                    cls_path = meta
                    plugin_cfg = {}
                elif isinstance(meta, Mapping):
                    cls_path = meta.get("type") or meta.get("class")
                    plugin_cfg = {
                        k: v for k, v in meta.items() if k not in {"type", "class"}
                    }
                else:  # pragma: no cover - defensive
                    continue
                plugin_cls = plugin_utils.import_plugin_class(cls_path)

                if issubclass(plugin_cls, ResourcePlugin):
                    layer = {
                        "infrastructure": 1,
                        "resources": 2,
                        "agent_resources": 3,
                        "custom_resources": 4,
                    }.get(section, 3)
                    self.resource_registry.register(
                        name, plugin_cls, plugin_cfg, layer=layer
                    )
                    continue

                if issubclass(plugin_cls, ToolPlugin):
                    instance = plugin_cls(plugin_cfg)
                    asyncio.run(self.tool_registry.add(name, instance))
                    continue

                instance = plugin_cls(plugin_cfg)
                self.add_plugin(instance)

    # ------------------------------ runtime build -----------------------------
    def build_runtime(
        self, workflow: Mapping[PipelineStage | str, Iterable[str]] | None = None
    ) -> "AgentRuntime":
        asyncio.run(self.resource_registry.build_all())
        for plugin in self._added_plugins:
            init = getattr(plugin, "initialize", None)
            if callable(init):
                asyncio.run(init())
        capabilities = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return AgentRuntime(capabilities)

    def shutdown(self) -> None:
        """Shut down plugins and resources."""

        for plugin in reversed(self._added_plugins):
            shutdown = getattr(plugin, "shutdown", None)
            if callable(shutdown):
                asyncio.run(shutdown())
        asyncio.run(self.resource_registry.shutdown_all())

    # ------------------------------ internals --------------------------------
    def _import_module(self, file: Path) -> ModuleType | None:
        import importlib.util

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception as exc:  # noqa: BLE001
            logger.error(
                "Failed to import plugin module %s: %s",
                file,
                exc,
                extra={"pipeline_id": "builder", "stage": "initialization"},
            )
            return None

    def _type_default_stages(self, plugin: Plugin) -> list[PipelineStage]:
        if isinstance(plugin, ToolPlugin):
            return [PipelineStage.DO]
        if isinstance(plugin, PromptPlugin):
            return [PipelineStage.THINK]
        if isinstance(plugin, AdapterPlugin):
            return [PipelineStage.INPUT, PipelineStage.OUTPUT]
        return []

    def _resolve_plugin_stages(
        self, plugin: Plugin, config: Mapping[str, Any] | None
    ) -> list[PipelineStage]:
        """Resolve final stages for ``plugin`` with sane fallbacks."""

        cfg_val = None
        if config is not None:
            cfg_val = config.get("stages") or config.get("stage")

        if cfg_val is not None:
            if not isinstance(cfg_val, list):
                cfg_val = [cfg_val]
            return [PipelineStage.ensure(s) for s in cfg_val]

        class_stages = getattr(plugin, "stages", [])
        if class_stages:
            return [PipelineStage.ensure(s) for s in class_stages]

        type_default = self._type_default_stages(plugin)
        if type_default:
            return [PipelineStage.ensure(s) for s in type_default]

        return [PipelineStage.THINK]

    def _register_module_plugins(self, module: ModuleType) -> None:
        import inspect

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and (issubclass(obj, Plugin) or issubclass(obj, PluginInterface))
                    and obj not in {Plugin, PluginInterface}
                ):
                    try:
                        instance = obj()
                    except TypeError:
                        instance = obj({})
                    self.add_plugin(instance)
                elif callable(obj) and hasattr(obj, "__entity_plugin__"):
                    self.add_plugin(getattr(obj, "__entity_plugin__"))
                elif callable(obj) and name.endswith("_plugin"):
                    self.plugin(obj)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to register plugin from %s.%s: %s",
                    module.__name__,
                    name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
