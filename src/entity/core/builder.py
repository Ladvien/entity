from __future__ import annotations

"""Pipeline component: builder."""

import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from types import ModuleType
from typing import Any, Callable, Iterable, Mapping, Optional

from entity.core import plugin_utils
from entity.core.plugins import AdapterPlugin, AutoGeneratedPlugin
from entity.core.plugins import BasePlugin
from entity.core.plugins import BasePlugin as BasePluginInterface
from entity.core.plugins import BasePlugin as BasePluginType
from entity.core.plugins import PromptPlugin, ToolPlugin
from entity.core.registries import PluginRegistry, SystemRegistries, ToolRegistry
from entity.core.resources.container import ResourceContainer
from entity.core.runtime import AgentRuntime
from entity.utils.logging import get_logger

from pipeline.utils import resolve_stages

from .plugin_utils import PluginAutoClassifier
from .stages import PipelineStage

logger = get_logger(__name__)


@dataclass
class _AgentBuilder:
    """Collect plugins and build :class:`AgentRuntime`."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceContainer = field(default_factory=ResourceContainer)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)

    def __post_init__(self) -> None:
        """Configure plugin system on first construction."""
        if plugin_utils.plugin_base_registry.auto_plugin is object:
            plugin_utils.configure_plugins(
                BasePluginType,
                PromptPlugin,
                AdapterPlugin,
                AutoGeneratedPlugin,
                ToolPlugin,
            )

    # ------------------------------ plugin utils ------------------------------
    def add_plugin(
        self, plugin: BasePlugin, config: Mapping[str, Any] | None = None
    ) -> None:
        """Validate and register ``plugin`` for its resolved stages."""

        if not hasattr(plugin, "_execute_impl") or not callable(
            getattr(plugin, "_execute_impl")
        ):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            raise TypeError(f"Plugin '{name}' must implement async '_execute_impl'")

        stages = self._resolve_plugin_stages(plugin, config)
        for stage in stages:
            name = getattr(plugin, "name", plugin.__class__.__name__)
            asyncio.run(
                self.plugin_registry.register_plugin_for_stage(plugin, stage, name)
            )

    def plugin(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a plugin."""

        def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
            plugin = PluginAutoClassifier.classify(f, hints)
            self.add_plugin(plugin)
            return f

        return decorator(func) if func else decorator

    # ---------------------------- discovery helpers ---------------------------
    @classmethod
    def from_directory(cls, directory: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_directory(directory)
        return builder

    @classmethod
    def from_package(cls, package_name: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_package(package_name)
        return builder

    def load_plugins_from_directory(self, directory: str) -> None:
        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def load_plugins_from_package(self, package_name: str) -> None:
        import importlib
        import pkgutil

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            self._register_module_plugins(package)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to import plugin module %s: %s",
                    info.name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
            self._register_module_plugins(module)

    # ------------------------------ config helpers -----------------------------
    @classmethod
    def from_yaml(cls, yaml_path: str) -> "_AgentBuilder":
        """Create a builder from a YAML configuration file."""

        import yaml

        with open(yaml_path, "r", encoding="utf-8") as handle:
            data = yaml.safe_load(handle) or {}
        builder = cls()
        builder.load_from_dict(data)
        return builder

    def load_from_dict(self, cfg: Mapping[str, Any]) -> None:
        """Register plugins from a configuration mapping in listed order."""

        plugins_cfg = cfg.get("plugins", {})
        for _section, entries in plugins_cfg.items():
            if not isinstance(entries, Mapping):
                continue
            for _name, meta in entries.items():
                if isinstance(meta, str):
                    cls_path = meta
                    plugin_cfg = {}
                elif isinstance(meta, Mapping):
                    cls_path = meta.get("type") or meta.get("class")
                    plugin_cfg = {
                        k: v for k, v in meta.items() if k not in {"type", "class"}
                    }
                else:  # pragma: no cover - defensive
                    continue
                plugin_cls = plugin_utils.import_plugin_class(cls_path)
                instance = plugin_cls(plugin_cfg)
                self.add_plugin(instance)

    # ------------------------------ runtime build -----------------------------
    def build_runtime(
        self, workflow: Mapping[PipelineStage | str, Iterable[str]] | None = None
    ) -> "AgentRuntime":
        asyncio.run(self.resource_registry.build_all())
        capabilities = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        return AgentRuntime(capabilities)

    # ------------------------------ internals --------------------------------
    def _import_module(self, file: Path) -> ModuleType | None:
        import importlib.util

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception as exc:  # noqa: BLE001
            logger.error(
                "Failed to import plugin module %s: %s",
                file,
                exc,
                extra={"pipeline_id": "builder", "stage": "initialization"},
            )
            return None

    def _type_default_stages(self, plugin: BasePlugin) -> list[PipelineStage]:
        if isinstance(plugin, ToolPlugin):
            return [PipelineStage.DO]
        if isinstance(plugin, PromptPlugin):
            return [PipelineStage.THINK]
        if isinstance(plugin, AdapterPlugin):
            return [PipelineStage.PARSE, PipelineStage.DELIVER]
        return []

    def _resolve_plugin_stages(
        self, plugin: BasePlugin, config: Mapping[str, Any] | None
    ) -> list[PipelineStage]:
        cfg_val = None
        if config is not None:
            cfg_val = config.get("stages") or config.get("stage")

        explicit_attr = getattr(plugin, "_explicit_stages", False) or (
            "stages" in plugin.__class__.__dict__
        )

        stages, _ = resolve_stages(
            plugin.__class__.__name__,
            cfg_value=cfg_val,
            attr_stages=getattr(plugin, "stages", []),
            explicit_attr=explicit_attr,
            type_defaults=self._type_default_stages(plugin),
            ensure_stage=PipelineStage.ensure,
            logger=logger,
            auto_inferred=getattr(plugin, "_auto_inferred_stages", False),
            error_type=ValueError,
        )
        return stages

    def _register_module_plugins(self, module: ModuleType) -> None:
        import inspect

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and (
                        issubclass(obj, BasePlugin)
                        or issubclass(obj, BasePluginInterface)
                    )
                    and obj not in {BasePlugin, BasePluginInterface}
                ):
                    try:
                        instance = obj()
                    except TypeError:
                        instance = obj({})
                    self.add_plugin(instance)
                elif callable(obj) and hasattr(obj, "__entity_plugin__"):
                    self.add_plugin(getattr(obj, "__entity_plugin__"))
                elif callable(obj) and name.endswith("_plugin"):
                    self.plugin(obj)
            except Exception as exc:  # noqa: BLE001
                logger.error(
                    "Failed to register plugin from %s.%s: %s",
                    module.__name__,
                    name,
                    exc,
                    extra={"pipeline_id": "builder", "stage": "initialization"},
                )
                continue
