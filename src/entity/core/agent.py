from __future__ import annotations

"""Pipeline component: agent."""

import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from types import ModuleType
from typing import Any, Callable, Dict, Iterable, Mapping, Optional, Type, cast

from entity.core import plugin_utils
from .plugin_utils import PluginAutoClassifier
from entity.pipeline.exceptions import PipelineError
from entity.pipeline.utils import StageResolver
from entity.pipeline.stages import PipelineStage

from .plugins import (
    AdapterPlugin,
    AutoGeneratedPlugin,
    FailurePlugin,
    Plugin,
    PromptPlugin,
    ResourcePlugin,
    ToolPlugin,
)
from .registries import PluginRegistry, SystemRegistries, ToolRegistry
from .resources.container import ResourceContainer
from entity.workflows.base import Workflow
from entity.workflows.discovery import discover_workflows, register_module_workflows

from typing import TYPE_CHECKING

if TYPE_CHECKING:  # pragma: no cover - type checking
    from entity.pipeline.workflow import Pipeline
else:  # pragma: no cover - runtime circular import guard
    Pipeline = object


@dataclass(init=False)
class _AgentRuntime:
    """Minimal runtime executor for an Agent."""

    capabilities: SystemRegistries
    workflow: Workflow | None = None
    manager: Any = field(init=False)

    def __init__(
        self, capabilities: SystemRegistries, *, workflow: Workflow | None = None
    ) -> None:
        self.capabilities = capabilities
        self.workflow = workflow
        if self.workflow is not None:
            self.workflow.validate_plugins(capabilities.plugins)
        self.__post_init__()

    def __post_init__(self) -> None:
        self.manager = None

    async def run_pipeline(self, message: str, *, user_id: str | None = None) -> Any:
        from entity.pipeline.pipeline import Pipeline as ExecPipeline, execute_pipeline

        if self.workflow is None:
            return await execute_pipeline(
                message, self.capabilities, user_id=user_id, workflow=None
            )

        pipeline = ExecPipeline(self.workflow)
        return await pipeline.run_message(message, self.capabilities, user_id=user_id)

    async def handle(
        self, message: str, *, user_id: str | None = None
    ) -> Dict[str, Any]:
        return await self.run_pipeline(message, user_id=user_id)


@dataclass
class _AgentBuilder:
    """Collect plugins and build :class:`_AgentRuntime`."""

    plugin_registry: PluginRegistry = field(default_factory=PluginRegistry)
    resource_registry: ResourceContainer = field(default_factory=ResourceContainer)
    tool_registry: ToolRegistry = field(default_factory=ToolRegistry)
    _added_plugins: list[Plugin] = field(default_factory=list, init=False)

    # ------------------------------ utility helpers ---------------------------
    def has_plugin(self, name: str) -> bool:
        """Return ``True`` if a plugin, resource, or tool named ``name`` exists."""

        if self.plugin_registry.get_plugin(name) is not None:
            return True
        if self.resource_registry.get(name) is not None:
            return True
        if self.tool_registry.get(name) is not None:
            return True
        return False

    def list_plugins(self) -> list[str]:
        """Return sorted list of all registered plugin names."""

        names = set()
        for plugin in self.plugin_registry.list_plugins():
            names.add(self.plugin_registry.get_plugin_name(plugin))
        if hasattr(self.resource_registry, "list_plugins"):
            names.update(self.resource_registry.list_plugins())
        if hasattr(self.tool_registry, "list_plugins"):
            names.update(self.tool_registry.list_plugins())
        return sorted(names)

    def __post_init__(self) -> None:
        """Configure plugin registry on first use."""

        if plugin_utils.plugin_base_registry.auto_plugin is object:
            plugin_utils.configure_plugins(
                Plugin,
                PromptPlugin,
                AdapterPlugin,
                AutoGeneratedPlugin,
                ToolPlugin,
                FailurePlugin,
                ResourcePlugin,
            )

    # ------------------------------ plugin utils ------------------------------
    async def add_plugin(
        self, plugin: Plugin, config: Mapping[str, Any] | None = None
    ) -> None:
        """Validate and register ``plugin`` for its resolved stages."""

        if not hasattr(plugin, "_execute_impl") or not callable(
            getattr(plugin, "_execute_impl")
        ):
            name = getattr(plugin, "name", plugin.__class__.__name__)
            raise TypeError(f"Plugin '{name}' must implement async '_execute_impl'")

        result = await plugin.__class__.validate_config(plugin.config)
        if not result.success:
            raise SystemError(
                f"Config validation failed for {plugin.__class__.__name__}: {result.message}"
            )

        dep_result = await plugin.__class__.validate_dependencies(self)
        if not dep_result.success:
            raise SystemError(
                f"Dependency validation failed for {plugin.__class__.__name__}: {dep_result.message}"
            )

        cfg = plugin.config if config is None else config
        stages, _ = StageResolver._resolve_plugin_stages(plugin.__class__, cfg, plugin)
        for stage in stages:
            name = getattr(plugin, "name", plugin.__class__.__name__)
            await self.plugin_registry.register_plugin_for_stage(plugin, stage, name)

        self._added_plugins.append(plugin)

    def plugin(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a plugin."""

        def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
            if not (
                hints.get("plugin_class") or hints.get("stage") or hints.get("stages")
            ):
                raise ValueError("plugin() requires 'plugin_class' or stage hints")

            plugin = PluginAutoClassifier.classify(f, hints)
            stage_hint = hints.get("stages") or hints.get("stage")
            if stage_hint is not None:
                stages = StageResolver._resolve_plugin_stages(
                    plugin.__class__, {"stages": stage_hint}, plugin
                )[0]
                name = getattr(plugin, "name", plugin.__class__.__name__)
                for stage in stages:
                    asyncio.run(
                        self.plugin_registry.register_plugin_for_stage(
                            plugin, stage, name
                        )
                    )
                self._added_plugins.append(plugin)
            else:
                asyncio.run(self.add_plugin(plugin))
            return f

        return decorator(func) if func else decorator

    def tool(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a ``ToolPlugin``."""

        hints["plugin_class"] = ToolPlugin
        return self.plugin(func, **hints)

    def prompt(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a ``PromptPlugin``."""

        hints["plugin_class"] = PromptPlugin
        return self.plugin(func, **hints)

    # ---------------------------- discovery helpers ---------------------------
    @classmethod
    def from_directory(cls, directory: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_directory(directory)
        return builder

    @classmethod
    def from_package(cls, package_name: str) -> "_AgentBuilder":
        builder = cls()
        builder.load_plugins_from_package(package_name)
        return builder

    def load_plugins_from_directory(self, directory: str) -> None:
        for file in Path(directory).glob("*.py"):
            if file.name.startswith("_"):
                continue
            module = self._import_module(file)
            if module is not None:
                self._register_module_plugins(module)

    def load_plugins_from_package(self, package_name: str) -> None:
        import importlib
        import pkgutil

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            self._register_module_plugins(package)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception:  # noqa: BLE001
                continue
            self._register_module_plugins(module)

    # ------------------------------ config helpers ----------------------------
    @classmethod
    def from_yaml(cls, yaml_path: str) -> "_AgentBuilder":
        """Create a builder from a YAML configuration file."""

        import yaml

        with open(yaml_path, "r", encoding="utf-8") as handle:
            data = yaml.safe_load(handle) or {}
        builder = cls()
        builder.load_from_dict(data)
        return builder

    def load_from_dict(self, cfg: Mapping[str, Any]) -> None:
        """Register plugins from a configuration mapping in listed order."""

        plugins_cfg = cfg.get("plugins", {})
        for section, entries in plugins_cfg.items():
            if not isinstance(entries, Mapping):
                continue
            for name, meta in entries.items():
                if isinstance(meta, str):
                    cls_path = meta
                    plugin_cfg = {}
                elif isinstance(meta, Mapping):
                    cls_path = meta.get("type") or meta.get("class")
                    plugin_cfg = {
                        k: v for k, v in meta.items() if k not in {"type", "class"}
                    }
                else:  # pragma: no cover - defensive
                    continue
                plugin_cls = plugin_utils.import_plugin_class(cls_path)

                if issubclass(plugin_cls, ResourcePlugin):
                    layer = {
                        "infrastructure": 1,
                        "resources": 2,
                        "agent_resources": 3,
                        "custom_resources": 4,
                    }.get(section, 3)
                    self.resource_registry.register(
                        name, plugin_cls, plugin_cfg, layer=layer
                    )
                    continue

                if issubclass(plugin_cls, ToolPlugin):
                    instance = plugin_cls(plugin_cfg)
                    asyncio.run(self.tool_registry.add(name, instance))
                    continue

                instance = plugin_cls(plugin_cfg)
                asyncio.run(self.add_plugin(instance))

    def _register_default_resources(self) -> None:
        """Ensure canonical resources exist with simple implementations."""

        container = self.resource_registry

        if not container.has_plugin("database_backend"):
            from entity.infrastructure.duckdb import DuckDBInfrastructure

            container.register("database_backend", DuckDBInfrastructure, {}, layer=1)

        if not container.has_plugin("database"):
            from entity.resources.interfaces.duckdb_resource import DuckDBResource

            container.register("database", DuckDBResource, {}, layer=2)

        if not container.has_plugin("vector_store"):
            from entity.resources.interfaces.duckdb_vector_store import (
                DuckDBVectorStore,
            )

            container.register("vector_store", DuckDBVectorStore, {}, layer=2)

        if not container.has_plugin("memory"):
            from entity.resources.memory import Memory

            container.register("memory", Memory, {}, layer=3)

        if not container.has_plugin("llm_provider"):
            from entity.resources.interfaces.echo_llm import EchoLLMResource

            container.register("llm_provider", EchoLLMResource, {}, layer=4)

        if not container.has_plugin("llm"):
            from entity.resources.llm import LLM

            container.register("llm", LLM, {}, layer=3)

        if not container.has_plugin("storage"):
            from entity.resources.storage import Storage

            container.register("storage", Storage, {}, layer=3)

    def _assign_shared_resources(self, plugin: Plugin) -> None:
        """Attach common resources to ``plugin`` if available."""

        metrics = self.resource_registry.get("metrics_collector")
        if metrics is not None:
            setattr(plugin, "metrics_collector", metrics)

        logger_res = self.resource_registry.get("logging")
        if logger_res is not None:
            setattr(plugin, "logging", logger_res)

    # ------------------------------ runtime build -----------------------------
    async def build_runtime(
        self, workflow: Mapping[PipelineStage | str, Iterable[str]] | None = None
    ) -> "_AgentRuntime":
        self._register_default_resources()
        await self.resource_registry.build_all()
        for plugin in self._added_plugins:
            self._assign_shared_resources(plugin)
            init = getattr(plugin, "initialize", None)
            if callable(init):
                await init()
        capabilities = SystemRegistries(
            resources=self.resource_registry,
            tools=self.tool_registry,
            plugins=self.plugin_registry,
        )
        wf_obj = None
        if workflow is not None:
            wf_obj = (
                workflow
                if isinstance(workflow, Workflow)
                else Workflow.from_dict(workflow)
            )
            wf_obj.validate_plugins(self)
        return _AgentRuntime(capabilities, workflow=wf_obj)

    def shutdown(self) -> None:
        """Shut down plugins and resources."""

        for plugin in reversed(self._added_plugins):
            shutdown = getattr(plugin, "shutdown", None)
            if callable(shutdown):
                asyncio.run(shutdown())
        asyncio.run(self.resource_registry.shutdown_all())

    # ------------------------------ internals --------------------------------
    def _import_module(self, file: Path) -> ModuleType | None:
        import importlib.util

        try:
            spec = importlib.util.spec_from_file_location(file.stem, file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
            raise ImportError(f"Cannot load spec for {file}")
        except Exception:  # noqa: BLE001
            return None

    def _register_module_plugins(self, module: ModuleType) -> None:
        import inspect

        for name, obj in vars(module).items():
            if name.startswith("_"):
                continue
            try:
                if (
                    inspect.isclass(obj)
                    and (issubclass(obj, Plugin) or issubclass(obj, Plugin))
                    and obj not in {Plugin}
                ):
                    try:
                        instance = obj()
                    except TypeError:
                        instance = obj({})
                    asyncio.run(self.add_plugin(instance))
                elif callable(obj) and hasattr(obj, "__entity_plugin__"):
                    asyncio.run(self.add_plugin(getattr(obj, "__entity_plugin__")))
                elif callable(obj) and name.endswith("_plugin"):
                    self.plugin(obj)
            except Exception:  # noqa: BLE001
                continue


@dataclass(init=False)
class Agent:
    """High level agent wrapper combining builder and runtime."""

    config_path: str | None = None
    pipeline: Pipeline | None = None
    workflow: Workflow | None = None
    _builder: _AgentBuilder | None = field(default=None, init=False)
    _runtime: AgentRuntime | None = field(default=None, init=False)
    _workflows: dict[str, type] = field(default_factory=dict, init=False)

    def __init__(
        self,
        config_path: str | None = None,
        pipeline: Pipeline | None = None,
        workflow: Workflow | None = None,
    ) -> None:
        self.config_path = config_path
        self.pipeline = pipeline
        self.workflow = workflow
        self._builder = None
        self._runtime = None
        self._workflows = {}

    @property
    def builder(self) -> _AgentBuilder:
        """Lazily create and return an :class:`_AgentBuilder`."""

        if self._builder is None:
            self._builder = _AgentBuilder()
        return self._builder

    # ------------------------------------------------------------------
    # Delegated plugin helpers
    # ------------------------------------------------------------------
    async def add_plugin(self, plugin: Any) -> None:  # pragma: no cover - delegation
        """Register a plugin on the underlying builder."""

        await self.builder.add_plugin(plugin)
        if self._runtime is not None:
            stages, _ = StageResolver._resolve_plugin_stages(
                plugin.__class__, plugin.config, plugin
            )
            for stage in stages:
                name = getattr(plugin, "name", plugin.__class__.__name__)
                await self._runtime.capabilities.plugins.register_plugin_for_stage(
                    plugin, stage, name
                )

    def plugin(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator for registering ``func`` as a plugin."""

        return self.builder.plugin(func, **hints)

    def tool(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a ``ToolPlugin``."""

        hints["plugin_class"] = ToolPlugin
        return self.plugin(func, **hints)

    def prompt(
        self,
        func: Optional[Callable[..., Any]] = None,
        **hints: Any,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]] | Callable[..., Any]:
        """Decorator registering ``func`` as a ``PromptPlugin``."""

        hints["plugin_class"] = PromptPlugin
        return self.plugin(func, **hints)

    def load_plugins_from_directory(
        self, directory: str
    ) -> None:  # pragma: no cover - delegation
        """Load and register all plugins from ``directory``."""

        self.builder.load_plugins_from_directory(directory)

    def load_plugins_from_package(
        self, package_name: str
    ) -> None:  # pragma: no cover - delegation
        """Import a package and register any plugins it contains."""

        self.builder.load_plugins_from_package(package_name)

    def register_resource(
        self,
        name: str,
        cls: type,
        config: Mapping[str, Any] | None = None,
        *,
        layer: int | None = None,
    ) -> None:
        """Register a resource with the underlying builder."""

        self.builder.resource_registry.register(name, cls, config or {}, layer=layer)

    def has_plugin(self, name: str) -> bool:
        """Return True if a plugin, resource or tool named ``name`` exists."""

        return self.builder.has_plugin(name)

    async def build_runtime(
        self,
        workflow: Mapping[PipelineStage | str, Iterable[str]] | Workflow | None = None,
    ) -> AgentRuntime:
        """Build and assign a runtime using the internal builder."""

        wf_obj = None
        if workflow is not None:
            wf_obj = (
                workflow
                if isinstance(workflow, Workflow)
                else Workflow.from_dict(workflow)
            )
            wf_obj.validate_plugins(self.builder)

        self._runtime = await self.builder.build_runtime(wf_obj)
        return self._runtime

    def shutdown(self) -> None:
        """Shut down plugins and resources."""

        self.builder.shutdown()

    # ------------------------------------------------------------------
    # Workflow helpers
    # ------------------------------------------------------------------
    @property
    def workflows(self) -> Dict[str, Type[Workflow]]:
        return self._workflows

    def load_workflows_from_directory(self, directory: str) -> None:
        self._workflows.update(discover_workflows(directory))

    def load_workflows_from_package(self, package_name: str) -> None:
        import importlib
        import pkgutil

        package = importlib.import_module(package_name)
        if not hasattr(package, "__path__"):
            register_module_workflows(package, self._workflows)
            return

        for info in pkgutil.walk_packages(
            package.__path__, prefix=package.__name__ + "."
        ):
            try:
                module = importlib.import_module(info.name)
            except Exception:  # noqa: BLE001
                continue
            register_module_workflows(module, self._workflows)

    @classmethod
    def from_directory(
        cls, directory: str, *, workflow: Workflow | None = None
    ) -> "Agent":
        agent = cls(workflow=workflow)
        agent.load_plugins_from_directory(directory)
        return agent

    @classmethod
    def from_package(
        cls, package_name: str, *, workflow: Workflow | None = None
    ) -> "Agent":
        agent = cls(workflow=workflow)
        agent.load_plugins_from_package(package_name)
        return agent

    @classmethod
    def from_config(
        cls,
        cfg: str | Mapping[str, Any],
        *,
        env_file: str = ".env",
        strict_stages: bool = False,
    ) -> "Agent":
        """Instantiate an agent from a YAML/JSON path or mapping."""

        import asyncio
        from pathlib import Path

        from entity.pipeline.initializer import SystemInitializer

        if isinstance(cfg, Mapping):
            initializer = SystemInitializer.from_dict(
                cfg, env_file, strict_stages=strict_stages
            )
            path = None
        else:
            path = str(cfg)
            suffix = Path(path).suffix
            if suffix == ".json":
                initializer = SystemInitializer.from_json(
                    path, env_file, strict_stages=strict_stages
                )
            else:
                initializer = SystemInitializer.from_yaml(
                    path, env_file, strict_stages=strict_stages
                )

        async def _build() -> tuple[AgentRuntime, dict[str, type]]:
            plugins, resources, tools, wf = await initializer.initialize()
            caps = SystemRegistries(
                resources=resources,
                tools=tools,
                plugins=plugins,
            )
            return AgentRuntime(caps, workflow=wf), initializer.workflows

        runtime, workflows = asyncio.run(_build())
        agent = cls(config_path=path)
        agent._runtime = runtime
        agent._workflows = workflows
        return agent

    # ------------------------------------------------------------------
    async def _ensure_runtime(self) -> None:
        if self._runtime is None:
            wf = self.workflow
            if wf is None and self.pipeline:
                wf = (
                    self.pipeline.workflow
                    if hasattr(self.pipeline, "workflow")
                    else self.pipeline
                )
            self._runtime = await self.builder.build_runtime(workflow=wf)

    @property
    def runtime(self) -> AgentRuntime:
        if self._runtime is None:
            raise PipelineError("Agent not initialized; call an async method")
        return self._runtime

    async def run_message(
        self, message: str, *, user_id: str | None = None
    ) -> Dict[str, Any]:
        """Run ``message`` through the runtime pipeline and return results."""

        await self._ensure_runtime()
        if self._runtime is None:  # pragma: no cover - sanity check
            raise RuntimeError("Runtime not initialized")
        runtime = cast(AgentRuntime, self._runtime)
        return cast(
            Dict[str, Any], await runtime.run_pipeline(message, user_id=user_id)
        )

    async def handle(
        self, message: str, *, user_id: str | None = None
    ) -> Dict[str, Any]:
        """Public alias for :meth:`run_message`."""

        return await self.run_message(message, user_id=user_id)

    def get_capabilities(self) -> SystemRegistries:
        if self._runtime is None:
            raise PipelineError("Agent not initialized")
        return self._runtime.capabilities

    async def serve_http(self, **config: Any) -> None:
        """Run the agent via the built-in HTTP adapter."""

        await self._ensure_runtime()
        from plugins.builtin.adapters.server import AgentServer

        server = AgentServer(
            capabilities=self.runtime.capabilities, manager=self.runtime.manager
        )
        await server.serve_http(**config)

    async def serve_websocket(self, **config: Any) -> None:
        """Run the agent via the built-in WebSocket adapter."""

        await self._ensure_runtime()
        from plugins.builtin.adapters.server import AgentServer

        server = AgentServer(
            capabilities=self.runtime.capabilities, manager=self.runtime.manager
        )
        await server.serve_websocket(**config)

    async def serve_cli(self, **config: Any) -> None:
        """Run the agent via the built-in CLI adapter."""

        await self._ensure_runtime()
        from plugins.builtin.adapters.server import AgentServer

        server = AgentServer(
            capabilities=self.runtime.capabilities, manager=self.runtime.manager
        )
        await server.serve_cli(**config)


AgentRuntime = _AgentRuntime

__all__ = ["Agent", "_AgentRuntime", "AgentRuntime"]
