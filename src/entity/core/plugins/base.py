from __future__ import annotations

"""Core plugin wrappers for the Entity framework.

These classes mirror the minimal architecture described in
``architecture/general.md`` and avoid importing ``entity.core.plugins``.
They offer a small, easy to understand surface for plugin authors.
"""

import asyncio
import time
from dataclasses import dataclass
from typing import Any, Dict, List

from entity.utils.logging import get_logger

from ..stages import PipelineStage


class ToolExecutionError(Exception):
    """Raised when a tool fails during execution."""


class BasePlugin:
    """Foundation for all plugins."""

    stages: List[PipelineStage]
    dependencies: List[str] = []
    max_retries: int = 1
    retry_delay: float = 0.0

    def __init__(self, config: Dict[str, Any] | None = None) -> None:
        self.config = config or {}
        self.logger = get_logger(self.__class__.__name__)
        self._config_history: list[Dict[str, Any]] = [self.config.copy()]
        self.config_version: int = 1

    # -----------------------------------------------------
    def supports_runtime_reconfiguration(self) -> bool:
        """Return ``True`` if the plugin can be reconfigured without restart."""

        return True

    async def rollback_config(self, version: int) -> None:
        """Revert to the specified configuration version."""

        if version < 1 or version > len(self._config_history):
            raise ValueError("invalid version")
        self.config = self._config_history[version - 1].copy()
        self.config_version = version
        self._config_history = self._config_history[:version]

    async def execute(self, context: Any) -> Any:
        for attempt in range(self.max_retries + 1):
            try:
                return await self._execute_impl(context)
            except Exception:  # noqa: BLE001 - propagate after retries
                if attempt >= self.max_retries:
                    raise
                await asyncio.sleep(self.retry_delay)
        return None

    async def _execute_impl(self, context: Any) -> Any:
        """Execute plugin logic in the pipeline."""
        raise NotImplementedError

    async def call_llm(self, context: Any, prompt: str, purpose: str = "") -> Any:
        start = time.perf_counter()
        response = await context.call_llm(context, prompt, purpose=purpose)
        duration = time.perf_counter() - start
        if context.get_failure_info() is None and hasattr(context._state, "metrics"):
            key = f"{context.current_stage}:{self.__class__.__name__}:{purpose}"
            context._state.metrics.record_llm_duration(key, duration)
        self.logger.info(
            "LLM call completed",
            extra={
                "plugin": self.__class__.__name__,
                "stage": str(getattr(context, "current_stage", "")),
                "purpose": purpose,
                "prompt_length": len(prompt),
                "response_length": len(getattr(response, "content", "")),
                "pipeline_id": getattr(context, "pipeline_id", ""),
                "duration": duration,
            },
        )
        return response


class ResourcePlugin(BasePlugin):
    """Infrastructure plugin providing persistent resources."""


class ToolPlugin(BasePlugin):
    """Utility plugin executed via ``tool_use`` calls."""

    required_params: List[str] = []

    async def execute_function(self, params: Dict[str, Any]) -> Any:
        raise NotImplementedError

    async def execute_function_with_retry(self, params: Dict[str, Any]) -> Any:
        for name in self.required_params:
            if name not in params:
                raise ToolExecutionError(f"Missing parameter: {name}")
        for attempt in range(self.max_retries + 1):
            try:
                return await self.execute_function(params)
            except Exception:
                if attempt >= self.max_retries:
                    raise
                await asyncio.sleep(self.retry_delay)
        raise RuntimeError("unreachable")


class PromptPlugin(BasePlugin):
    """Processing plugin typically run in ``THINK`` stage."""

    stages = [PipelineStage.THINK]


class AdapterPlugin(BasePlugin):
    """Input or output adapter plugin."""

    stages = [PipelineStage.PARSE, PipelineStage.DELIVER]


class FailurePlugin(BasePlugin):
    """Error handling plugin for the ``ERROR`` stage."""

    stages = [PipelineStage.ERROR]


@dataclass
class ValidationResult:
    success: bool
    message: str = ""

    @classmethod
    def success_result(cls) -> "ValidationResult":
        return cls(True, "")

    @classmethod
    def error_result(cls, message: str) -> "ValidationResult":
        return cls(False, message)


class ConfigurationError(Exception):
    """Raised when plugin configuration is invalid."""


@dataclass
class ReconfigResult:
    updated: bool


class AutoGeneratedPlugin(BasePlugin):
    """Wrapper created by :class:`PluginAutoClassifier`."""

    def __init__(
        self,
        func: Any,
        stages: list[PipelineStage],
        name: str,
        base_class: type[BasePlugin],
    ) -> None:
        super().__init__()
        self.func = func
        self.stages = stages
        self.name = name
        self.base_class = base_class

    async def _execute_impl(self, context: Any) -> Any:
        return await self.func(context)
