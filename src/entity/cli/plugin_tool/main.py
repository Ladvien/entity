from __future__ import annotations

import argparse
import asyncio
import importlib.util
import inspect
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Optional, Type

from entity.core.stages import PipelineStage

ROOT = Path(__file__).resolve().parent.parent  # noqa: E402
if str(ROOT) not in sys.path:  # noqa: E402
    sys.path.insert(0, str(ROOT))

from entity.core.plugins import (
    Plugin,
    FailurePlugin,
    PromptPlugin,
    ResourcePlugin,
    ToolPlugin,
    AdapterPlugin,
    AutoGeneratedPlugin,
    ValidationResult,
)
from entity.utils.logging import get_logger  # noqa: E402

from .generate import generate_plugin  # noqa: E402
from .utils import load_plugin  # noqa: E402

PLUGIN_TYPES: dict[str, Type[Plugin]] = {
    "resource": ResourcePlugin,
    "tool": ToolPlugin,
    "prompt": PromptPlugin,
    "adapter": AdapterPlugin,
    "failure": FailurePlugin,
}

logger = get_logger(__name__)


@dataclass
class PluginToolArgs:
    """Arguments parsed for :class:`PluginToolCLI`."""

    command: str
    name: Optional[str] = None
    type: Optional[str] = None
    out: Optional[str] = None
    docs_dir: Optional[str] = None
    path: Optional[str] = None
    paths: Optional[list[str]] = None


class PluginToolCLI:
    """CLI utility for working with Entity plugins."""

    def __init__(self) -> None:
        self.args: PluginToolArgs = self._parse_args()

    def _parse_args(self) -> PluginToolArgs:
        parser = argparse.ArgumentParser(
            description="Helper tool for creating and validating Entity plugins"
        )
        sub = parser.add_subparsers(dest="command", required=True)

        gen = sub.add_parser("generate", help="Generate plugin boilerplate")
        gen.add_argument("name", help="Plugin name")
        gen.add_argument("--type", required=True, choices=list(PLUGIN_TYPES))
        gen.add_argument("--out", default="src", help="Output directory")
        gen.add_argument("--docs-dir", default="docs/source")

        scaffold = sub.add_parser("scaffold", help="Create a standalone plugin project")
        scaffold.add_argument("name", help="Plugin name")
        scaffold.add_argument("--type", required=True, choices=list(PLUGIN_TYPES))
        scaffold.add_argument(
            "--out",
            default="user_plugins",
            help="Directory to create the project in",
        )

        val = sub.add_parser("validate", help="Validate plugin structure")
        val.add_argument("path", help="Path to plugin file")

        tst = sub.add_parser("test", help="Run plugin in isolation")
        tst.add_argument("path", help="Path to plugin file")

        cfg = sub.add_parser("config", help="Interactive configuration builder")
        cfg.add_argument("--name", required=True)
        cfg.add_argument("--type", required=True, choices=list(PLUGIN_TYPES))

        dep = sub.add_parser("deps", help="Analyze plugin dependencies")
        dep.add_argument("paths", nargs="+", help="Plugin module paths")

        doc = sub.add_parser("docs", help="Generate documentation for plugin")
        doc.add_argument("path", help="Plugin file path")
        doc.add_argument("--out", default="docs/source")

        ana = sub.add_parser(
            "analyze-plugin",
            help=(
                "Show plugin stages and whether they come from config hints"
                " or class attributes"
            ),
        )
        ana.add_argument("path", help="Plugin file path")

        parsed = parser.parse_args()
        return PluginToolArgs(
            command=parsed.command,
            name=getattr(parsed, "name", None),
            type=getattr(parsed, "type", None),
            out=getattr(parsed, "out", None),
            docs_dir=getattr(parsed, "docs_dir", None),
            path=getattr(parsed, "path", None),
            paths=getattr(parsed, "paths", None),
        )

    # -----------------------------------------------------
    # command implementations
    # -----------------------------------------------------
    def run(self) -> int:
        cmd = self.args.command
        if cmd == "generate":
            return self._generate()
        if cmd == "validate":
            return self._validate()
        if cmd == "scaffold":
            return self._scaffold()
        if cmd == "test":
            return self._test()
        if cmd == "config":
            return self._config()
        if cmd == "deps":
            return self._deps()
        if cmd == "docs":
            return self._docs()
        if cmd == "analyze-plugin":
            return self._analyze_plugin()
        return 0

    def _generate(self) -> int:
        assert self.args.name is not None
        assert self.args.type is not None
        assert self.args.out is not None
        assert self.args.docs_dir is not None
        return generate_plugin(
            self.args.name,
            self.args.type,
            Path(self.args.out),
            Path(self.args.docs_dir),
        )

    def _validate(self) -> int:
        assert self.args.path is not None
        plugin_cls = self._load_plugin(self.args.path)
        if not issubclass(plugin_cls, Plugin):
            logger.error("Not a plugin class")
            return 1
        if not getattr(plugin_cls, "stages", None):
            logger.error("Plugin does not define stages")
            return 1
        result = asyncio.run(
            plugin_cls.validate_config(getattr(plugin_cls, "config", {}))
        )
        if not isinstance(result, ValidationResult) or not result.success:
            logger.error("Config validation failed: %s", result.error_message)
            return 1

        class _DummyRegistry:
            def has_plugin(self, _name: str) -> bool:
                return False

            def list_plugins(self) -> list[str]:
                return []

        dep_result = asyncio.run(plugin_cls.validate_dependencies(_DummyRegistry()))
        if not isinstance(dep_result, ValidationResult) or not dep_result.success:
            logger.error("Dependency validation failed: %s", dep_result.error_message)
            return 1
        logger.info("Validation succeeded")
        return 0

    def _test(self) -> int:
        assert self.args.path is not None
        plugin_cls = self._load_plugin(self.args.path)

        async def _run() -> None:
            plugin = plugin_cls(getattr(plugin_cls, "config", {}))
            if hasattr(plugin, "initialize") and callable(plugin.initialize):
                logger.info("Initializing plugin...")
                await plugin.initialize()

            from entity.core.agent import Agent
            from entity.pipeline.workflow import Pipeline as PipelineWrapper

            # Tool plugins execute directly since pipelines don't call them
            if issubclass(plugin_cls, ToolPlugin):
                logger.info("Executing tool function...")
                await plugin.execute_function({})
                return

            agent = Agent()
            await agent.add_plugin(plugin)
            wf = {stage: [plugin_cls.__name__] for stage in plugin_cls.stages}
            pipeline = PipelineWrapper(builder=agent.builder, workflow=wf)
            runtime = await pipeline.build_runtime()
            result = await runtime.handle("test")
            logger.info("Pipeline result: %s", result)

        try:
            asyncio.run(_run())
        except Exception as exc:  # pragma: no cover - manual testing
            logger.error("Execution failed: %s", exc)
            return 1

        logger.info("Plugin executed successfully")
        return 0

    def _config(self) -> int:
        assert self.args.name is not None
        assert self.args.type is not None
        name = self.args.name
        plugin_type = self.args.type
        cfg: dict[str, str] = {}
        logger.info("Building configuration for %s (%s)", name, plugin_type)
        while True:
            key = input("key (blank to finish): ").strip()
            if not key:
                break
            value = input(f"value for '{key}': ").strip()
            cfg[key] = value
        section = self._section_for_type(plugin_type)
        import yaml

        output = yaml.dump({"plugins": {section: {name: cfg}}})
        logger.info("\n%s", output)
        return 0

    def _deps(self) -> int:
        assert self.args.paths is not None
        paths: list[str] = self.args.paths
        for p in paths:
            cls = self._load_plugin(p)
            deps = getattr(cls, "dependencies", [])
            name = cls.__name__
            logger.info(
                "%s: %s",
                name,
                ", ".join(deps) if deps else "no dependencies",
            )
        return 0

    def _scaffold(self) -> int:
        assert self.args.name is not None
        assert self.args.type is not None
        assert self.args.out is not None
        project_dir = Path(self.args.out) / self.args.name
        if project_dir.exists() and any(project_dir.iterdir()):
            logger.error("%s already exists and is not empty", project_dir)
            return 1
        src_dir = project_dir / "src"
        docs_dir = project_dir / "docs"
        tests_dir = project_dir / "tests"
        src_dir.mkdir(parents=True, exist_ok=True)
        docs_dir.mkdir(parents=True, exist_ok=True)
        tests_dir.mkdir(parents=True, exist_ok=True)

        template = Path("templates/plugins") / f"{self.args.type}.py"
        class_name = "".join(part.capitalize() for part in self.args.name.split("_"))
        content = template.read_text().format(class_name=class_name)
        (src_dir / f"{self.args.name}.py").write_text(content)
        (docs_dir / f"{self.args.name}.md").write_text(
            f"## {class_name}\n\n.. automodule:: {self.args.name}\n    :members:\n"
        )
        test_file = tests_dir / f"test_{self.args.name}.py"
        test_file.write_text(
            "from pathlib import Path\nfrom tests.plugins.harness import run_plugin\n\n"
            f"def test_{self.args.name}():\n"
            "    path = Path(__file__).parents[1] / 'src' / '{self.args.name}.py'\n"
            "    run_plugin(str(path))\n"
        )
        logger.info("Created plugin project at %s", project_dir)
        return 0

    def _docs(self) -> int:
        assert self.args.path is not None
        assert self.args.out is not None
        cls = self._load_plugin(self.args.path)
        out_dir = Path(self.args.out)
        out_dir.mkdir(parents=True, exist_ok=True)
        name = cls.__name__.lower()
        doc_path = out_dir / f"{name}.md"
        doc = inspect.getdoc(cls) or cls.__name__
        doc_path.write_text(f"# {cls.__name__}\n\n{doc}\n")
        logger.info("Documentation written to %s", doc_path)
        return 0

    def _analyze_plugin(self) -> int:
        assert self.args.path is not None
        path = self.args.path
        spec = importlib.util.spec_from_file_location(Path(path).stem, path)
        if spec is None or spec.loader is None:
            logger.error("Cannot import %s", path)
            return 1
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        from entity.core import plugin_utils
        from entity.core.plugin_utils import PluginAutoClassifier

        if plugin_utils.plugin_base_registry.auto_plugin is object:
            plugin_utils.configure_plugins(
                Plugin,
                PromptPlugin,
                AdapterPlugin,
                AutoGeneratedPlugin,
                ToolPlugin,
                FailurePlugin,
                ResourcePlugin,
            )

        selections: list[tuple[str, type, list]] = []
        found = False
        # Inspect async callables and classify them as plugins.
        # The reason indicates whether stages come from config hints or
        # default class attributes.
        for name, obj in module.__dict__.items():
            if name.startswith("_"):
                continue
            if inspect.iscoroutinefunction(obj):
                plugin = PluginAutoClassifier.classify(obj)
                stage_list = ", ".join(str(s) for s in plugin.stages)

                if getattr(plugin, "_explicit_stages", False):
                    reason = "config hints"
                else:
                    reason = "class attributes"

                logger.info("%s -> %s (%s)", name, stage_list, reason)
                prompt = f"Use these stages for {name}? [Y/n or comma list] "
                resp = input(prompt).strip()
                if resp and resp.lower() not in {"y", "yes"}:
                    if resp.lower() in {"n", "no"}:
                        override = input("Override stages (comma separated): ").strip()
                    else:
                        override = resp
                    try:
                        selected = [
                            PipelineStage.ensure(s.strip())
                            for s in override.split(",")
                            if s.strip()
                        ]
                    except ValueError as exc:
                        logger.error("Invalid stage: %s", exc)
                        return 1
                else:
                    selected = plugin.stages

                found = True
                selections.append((name, plugin.base_class, selected))

        if not found:
            logger.error("No async plugin functions found in %s", path)
            return 1

        config: dict[str, Any] = {"plugins": {}}
        for name, base_cls, stages in selections:
            section = self._section_for_base(base_cls)
            cfg = config["plugins"].setdefault(section, {})
            cfg[name] = {
                "type": f"{module.__name__}:{name}",
                "stages": [str(s) for s in stages],
            }

        import yaml

        output = yaml.dump(config, sort_keys=False)
        logger.info("\n%s", output)
        return 0

    # -----------------------------------------------------
    # helper methods
    # -----------------------------------------------------
    def _load_plugin(self, path: str) -> Type[Plugin]:
        return load_plugin(path)

    @staticmethod
    def _section_for_base(base: type[Plugin]) -> str:
        if issubclass(base, ResourcePlugin):
            return "resources"
        if issubclass(base, ToolPlugin):
            return "tools"
        if issubclass(base, AdapterPlugin):
            return "adapters"
        if issubclass(base, PromptPlugin):
            return "prompts"
        return "failures"

    @staticmethod
    def _section_for_type(ptype: str) -> str:
        if ptype == "resource":
            return "resources"
        if ptype == "tool":
            return "tools"
        if ptype == "adapter":
            return "adapters"
        if ptype == "prompt":
            return "prompts"
        return "failures"


def main() -> None:
    cli = PluginToolCLI()
    raise SystemExit(cli.run())


if __name__ == "__main__":  # pragma: no cover - CLI entrypoint
    main()
